<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--<meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c"></meta>--><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>USACO 2016 Jan Gold Analysis | Yutian’s Blog</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="USACO 2016 Jan Gold Analysis">
<meta name="author" content="Yutian (Mark) Chen">
<meta property="og:locale" content="en_US">
<meta name="description" content="Problem 1. Angry Cows Question Summary Link to Question The $N$ hey are on a line, with position $x_1, x_2, \cdots, x_N$. If the cow is shoot to position $x$ with force $R$, then all the cows in range $x \pm R$ will explode. The hey exploded will have a range of $x’ \pm (R - 1)$, the second round of hey exploded will have a range of $x’’ \pm (R-2)$, and so on. The question requires the minimum power $R$ with one-decimal accuracy that will let all hey on the line explode. \(2 \leq N \leq 50,000 \quad \quad \quad \forall n, 0 \leq x_n \leq 1,000,000\) Proposed Solution Binary Search There exists an $r’$ such that for all $R&gt;r’$ , all the hey on the line will explode, so it is possible to use binary search in this question. Storing all the positions $x_1$ to $x_n$ in a list, we can construct two pointers that represents the “frontier” of explosion. positions = [x1, x2, ..., xn] p1, p2 = None, None For each explosion, we can use a time complexity of $O(1)$ to update the pointer’s position. def updatePosition(p1, p2, R): if positions[p1-1] - positions[p1] &lt;= R: p1 -= 1 if positions[p2 + 1] - positions[p2] &lt;= R: p2 += 1 return p1, p2, R - 1 Therefore, it will take time of $O(n)$ for us to simulate one case. One optimization is to stop the simulation immediately and return false if the chain reaction stop If we try all the possible starting point, the total time complexity will be $O(n^2\log{n})$ and it will lead to TLE for Python. Noticing for all possible starting points, given a fixed force $R$, if starting at $x_i$ can lead a chain reaction that explode all, we note as true, otherwise, false, the resulting simulation result should look like this: Propagate_Leftward: [True, True, ..., True, True, True, False, ..., False] Propagate_Rightward: [False, False, ..., False, True, True, ..., True] Can_Explode_All = Propagate_Left and Propagate_Right We can use a binary search to find the starting point as well. def findStartLeft(l, r, R): # return True if current R can lead to a chain reaction m = (l + r)/2 if l &lt;= r: if explodePropagateLeft(l): return l else: return -1 if explodePropgateLeft(m): return findStartLeft(m, r, R) else: return findStartLeft(l, m-1, R) def findStartRight(l, r, R): m = (l + r)/2 if l &lt;= r: if explodePropagateRight(l): return l else: return -1 if explodePropgateRight(m): return findStartRight(l, m, R) else: return findStartRight(m+1, r, R) def isValid(l, r, R): return findStartLeft(l, r, R) &lt;= findStartRight(l, r, R) By using nested binary search, the time complexity can be reduced to $O(n\log{n}\log{n})$ Time Complexity Analysis With time complexity of $O(n \log{n}\log{n})$ and $n &lt; 50,000$, the approximate steps it need is $50,000 \times 16\times 16 = 1.3\times 10^7$ (Consider that we are performing two binary search to determine the existence of starting point, the actual computation step should multiply with factor of $2$, which is approx. $2.6\times 10^7$), which is an acceptable computational time complexity for Python 3. Problem 2. Radio Contact Link to Question Question Summary Farmer and Bessie are in a two-dimension space with size $1000\times 1000$. Farmer start at $f_x, f_y$, while Bessie start at $b_x, b_y$. ($0 \leq f_x, f_y, b_x, b_y \leq 1000$) Farmer will walk on a path of length $M$, which has “N”, “W”, “E”, “S” in the path and Bessie will walk on a path of length $N$, which has “N”, “W”, “E”, “S” in it. $0 \leq M, N \leq 1000$ At each tick, either Farmer or Bessie can choose to stay at current position. A radio that consumes energy of $\text{Distance}(Farmer, Bessie)^2$ will remain open until both farmer and Bessie finish their path. What is the minimum energy the radio will cost? Proposed Solution This question can be solved using Dynamic Programming. Build up a table with size $M \times N$ called $E$. $E[m][n]$ represent the minimum energy radio has consumed after farmer takes $m$ moves and Bessie takes $n$ moves. Since the square of distance is always non-negative, either farmer or Bessie (or both) will have to take one step in one tick. Therefore, the result at $E[m][n]$ can be used to calculate $E[m + 1][n]$, $E[m + 1][n + 1]$ and $E[m][n + 1]$, which represent that Bessie stop, no one stop, and Farmer stop, respectively. To start at a specific position, say $E[x][y]$ in the table, we must make sure the value on this position is already the minimum energy, which means that $E[x-1][y]$, $E[x-1][y-1]$, and $E[x][y-1]$ has been calculated. Therefore, we should calculate the whole table from top to down, and in each row from left to right. Time and Space Complexity Analysis Calculating the value of adjacent cell in a table will have a time complexity of $O(1)$, and we will have to calculate each cell inside the table, so the total time complexity will be $O(MN) \approx O(N^2)$. Since the upper bound of $N$ is only $1\times 10^3$, we can use Python3 to solve this problem. To store the result for Dynamic Programming (memorization), we have to build a two-dimensional array with size $1000\times 1000$, and the space complexity should not be a problem. Problem 3. Lights Out Link to Question Question Summary Bessie is on a vertex of a simple polygon with $n$ vertices. The coordinate of vertices are $(x_1, y_1), \cdots (x_n, y_n)$ listed in a clockwise order. The exit of polygon is located at $(x_1, y_1)$. When the light is out, she forgot which vertex she is on but still remember the whole polygon. By moving clockwise and passing through several edges, she will be able to identify the edge she is on. After she know her position, she will either move clockwise or counter clockwise to get to the nearest exit. The question asks the greatest difference between distance Bessie has to go in dark to exit the polygon and the distance Bessie has to go with lights on to exit the polygon in worst case. Sample Case Explanation Proposed Solution The Problem can be divide into two parts: Help Bessie identify its actual position (calculate the length Bessie has to walk clockwise to identify her position) Calculate the shortest distance between an arbitrary vertex on polygon and the exit. For the first part, we can convert the polygon to a string, where A, B, C and D represents four different types of corners, and integer $m$ represent the length of edge. For example, the polygon in sample can be represented as [\text{10C1D10A1}] One primitive way to find the shortest unique substring is to maintain a set of pointers, where the pointers represent the starting of one substring that has the same pattern. For instance, suppose we have a string “10C1D10A10C10A”, when Bessie pass by the first edge, she can get information “10C”. At this time, the pointer set will be {0, 8}, since [0:3] and [8:11] are both “10C”. Then, Bessie pass by another edge and get new info “1D”, the pointer set will be reduced to {0}. Since [0 + 3: 0+3+2] is “1D”, while “[8+3: 8+3+2]” is “10”. This will have a time complexity of $O(n^2)$. For the second part, we can store a list $\text{Dist}$ where $\text{Dist}[n]$ represent the distance between $n$th vertex and the exit when Bessie moves counterclockwise. Also, we will record the perimeter of whole polygon so that the distance between nth vertex and the exit when Bessie moves clockwise can be calculated using $\text{Perimeter}-\text{Dist}[n]$. This has a time complexity of $O(1)$. Since we $n$ vertexes to go through, the total time complexity will be $O(n^3)$. Time Complexity Analysis $4\leq N\leq 200$, so time complexity of $O(n^3)$ will only lead to a computational step of at most $1.6\times 10^7$ steps, and this problem can be solved by Python3 with the proposed solution.">
<meta property="og:description" content="Problem 1. Angry Cows Question Summary Link to Question The $N$ hey are on a line, with position $x_1, x_2, \cdots, x_N$. If the cow is shoot to position $x$ with force $R$, then all the cows in range $x \pm R$ will explode. The hey exploded will have a range of $x’ \pm (R - 1)$, the second round of hey exploded will have a range of $x’’ \pm (R-2)$, and so on. The question requires the minimum power $R$ with one-decimal accuracy that will let all hey on the line explode. \(2 \leq N \leq 50,000 \quad \quad \quad \forall n, 0 \leq x_n \leq 1,000,000\) Proposed Solution Binary Search There exists an $r’$ such that for all $R&gt;r’$ , all the hey on the line will explode, so it is possible to use binary search in this question. Storing all the positions $x_1$ to $x_n$ in a list, we can construct two pointers that represents the “frontier” of explosion. positions = [x1, x2, ..., xn] p1, p2 = None, None For each explosion, we can use a time complexity of $O(1)$ to update the pointer’s position. def updatePosition(p1, p2, R): if positions[p1-1] - positions[p1] &lt;= R: p1 -= 1 if positions[p2 + 1] - positions[p2] &lt;= R: p2 += 1 return p1, p2, R - 1 Therefore, it will take time of $O(n)$ for us to simulate one case. One optimization is to stop the simulation immediately and return false if the chain reaction stop If we try all the possible starting point, the total time complexity will be $O(n^2\log{n})$ and it will lead to TLE for Python. Noticing for all possible starting points, given a fixed force $R$, if starting at $x_i$ can lead a chain reaction that explode all, we note as true, otherwise, false, the resulting simulation result should look like this: Propagate_Leftward: [True, True, ..., True, True, True, False, ..., False] Propagate_Rightward: [False, False, ..., False, True, True, ..., True] Can_Explode_All = Propagate_Left and Propagate_Right We can use a binary search to find the starting point as well. def findStartLeft(l, r, R): # return True if current R can lead to a chain reaction m = (l + r)/2 if l &lt;= r: if explodePropagateLeft(l): return l else: return -1 if explodePropgateLeft(m): return findStartLeft(m, r, R) else: return findStartLeft(l, m-1, R) def findStartRight(l, r, R): m = (l + r)/2 if l &lt;= r: if explodePropagateRight(l): return l else: return -1 if explodePropgateRight(m): return findStartRight(l, m, R) else: return findStartRight(m+1, r, R) def isValid(l, r, R): return findStartLeft(l, r, R) &lt;= findStartRight(l, r, R) By using nested binary search, the time complexity can be reduced to $O(n\log{n}\log{n})$ Time Complexity Analysis With time complexity of $O(n \log{n}\log{n})$ and $n &lt; 50,000$, the approximate steps it need is $50,000 \times 16\times 16 = 1.3\times 10^7$ (Consider that we are performing two binary search to determine the existence of starting point, the actual computation step should multiply with factor of $2$, which is approx. $2.6\times 10^7$), which is an acceptable computational time complexity for Python 3. Problem 2. Radio Contact Link to Question Question Summary Farmer and Bessie are in a two-dimension space with size $1000\times 1000$. Farmer start at $f_x, f_y$, while Bessie start at $b_x, b_y$. ($0 \leq f_x, f_y, b_x, b_y \leq 1000$) Farmer will walk on a path of length $M$, which has “N”, “W”, “E”, “S” in the path and Bessie will walk on a path of length $N$, which has “N”, “W”, “E”, “S” in it. $0 \leq M, N \leq 1000$ At each tick, either Farmer or Bessie can choose to stay at current position. A radio that consumes energy of $\text{Distance}(Farmer, Bessie)^2$ will remain open until both farmer and Bessie finish their path. What is the minimum energy the radio will cost? Proposed Solution This question can be solved using Dynamic Programming. Build up a table with size $M \times N$ called $E$. $E[m][n]$ represent the minimum energy radio has consumed after farmer takes $m$ moves and Bessie takes $n$ moves. Since the square of distance is always non-negative, either farmer or Bessie (or both) will have to take one step in one tick. Therefore, the result at $E[m][n]$ can be used to calculate $E[m + 1][n]$, $E[m + 1][n + 1]$ and $E[m][n + 1]$, which represent that Bessie stop, no one stop, and Farmer stop, respectively. To start at a specific position, say $E[x][y]$ in the table, we must make sure the value on this position is already the minimum energy, which means that $E[x-1][y]$, $E[x-1][y-1]$, and $E[x][y-1]$ has been calculated. Therefore, we should calculate the whole table from top to down, and in each row from left to right. Time and Space Complexity Analysis Calculating the value of adjacent cell in a table will have a time complexity of $O(1)$, and we will have to calculate each cell inside the table, so the total time complexity will be $O(MN) \approx O(N^2)$. Since the upper bound of $N$ is only $1\times 10^3$, we can use Python3 to solve this problem. To store the result for Dynamic Programming (memorization), we have to build a two-dimensional array with size $1000\times 1000$, and the space complexity should not be a problem. Problem 3. Lights Out Link to Question Question Summary Bessie is on a vertex of a simple polygon with $n$ vertices. The coordinate of vertices are $(x_1, y_1), \cdots (x_n, y_n)$ listed in a clockwise order. The exit of polygon is located at $(x_1, y_1)$. When the light is out, she forgot which vertex she is on but still remember the whole polygon. By moving clockwise and passing through several edges, she will be able to identify the edge she is on. After she know her position, she will either move clockwise or counter clockwise to get to the nearest exit. The question asks the greatest difference between distance Bessie has to go in dark to exit the polygon and the distance Bessie has to go with lights on to exit the polygon in worst case. Sample Case Explanation Proposed Solution The Problem can be divide into two parts: Help Bessie identify its actual position (calculate the length Bessie has to walk clockwise to identify her position) Calculate the shortest distance between an arbitrary vertex on polygon and the exit. For the first part, we can convert the polygon to a string, where A, B, C and D represents four different types of corners, and integer $m$ represent the length of edge. For example, the polygon in sample can be represented as [\text{10C1D10A1}] One primitive way to find the shortest unique substring is to maintain a set of pointers, where the pointers represent the starting of one substring that has the same pattern. For instance, suppose we have a string “10C1D10A10C10A”, when Bessie pass by the first edge, she can get information “10C”. At this time, the pointer set will be {0, 8}, since [0:3] and [8:11] are both “10C”. Then, Bessie pass by another edge and get new info “1D”, the pointer set will be reduced to {0}. Since [0 + 3: 0+3+2] is “1D”, while “[8+3: 8+3+2]” is “10”. This will have a time complexity of $O(n^2)$. For the second part, we can store a list $\text{Dist}$ where $\text{Dist}[n]$ represent the distance between $n$th vertex and the exit when Bessie moves counterclockwise. Also, we will record the perimeter of whole polygon so that the distance between nth vertex and the exit when Bessie moves clockwise can be calculated using $\text{Perimeter}-\text{Dist}[n]$. This has a time complexity of $O(1)$. Since we $n$ vertexes to go through, the total time complexity will be $O(n^3)$. Time Complexity Analysis $4\leq N\leq 200$, so time complexity of $O(n^3)$ will only lead to a computational step of at most $1.6\times 10^7$ steps, and this problem can be solved by Python3 with the proposed solution.">
<link rel="canonical" href="https://markchenyutian.github.io//blog/2020/USACO-2016-Jan-Gold-Analysis.html">
<meta property="og:url" content="https://markchenyutian.github.io//blog/2020/USACO-2016-Jan-Gold-Analysis.html">
<meta property="og:site_name" content="Yutian’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-10-04T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="USACO 2016 Jan Gold Analysis">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yutian (Mark) Chen"},"dateModified":"2020-10-04T00:00:00+00:00","datePublished":"2020-10-04T00:00:00+00:00","description":"Problem 1. Angry Cows Question Summary Link to Question The $N$ hey are on a line, with position $x_1, x_2, \\cdots, x_N$. If the cow is shoot to position $x$ with force $R$, then all the cows in range $x \\pm R$ will explode. The hey exploded will have a range of $x’ \\pm (R - 1)$, the second round of hey exploded will have a range of $x’’ \\pm (R-2)$, and so on. The question requires the minimum power $R$ with one-decimal accuracy that will let all hey on the line explode. \\(2 \\leq N \\leq 50,000 \\quad \\quad \\quad \\forall n, 0 \\leq x_n \\leq 1,000,000\\) Proposed Solution Binary Search There exists an $r’$ such that for all $R&gt;r’$ , all the hey on the line will explode, so it is possible to use binary search in this question. Storing all the positions $x_1$ to $x_n$ in a list, we can construct two pointers that represents the “frontier” of explosion. positions = [x1, x2, ..., xn] p1, p2 = None, None For each explosion, we can use a time complexity of $O(1)$ to update the pointer’s position. def updatePosition(p1, p2, R): if positions[p1-1] - positions[p1] &lt;= R: p1 -= 1 if positions[p2 + 1] - positions[p2] &lt;= R: p2 += 1 return p1, p2, R - 1 Therefore, it will take time of $O(n)$ for us to simulate one case. One optimization is to stop the simulation immediately and return false if the chain reaction stop If we try all the possible starting point, the total time complexity will be $O(n^2\\log{n})$ and it will lead to TLE for Python. Noticing for all possible starting points, given a fixed force $R$, if starting at $x_i$ can lead a chain reaction that explode all, we note as true, otherwise, false, the resulting simulation result should look like this: Propagate_Leftward: [True, True, ..., True, True, True, False, ..., False] Propagate_Rightward: [False, False, ..., False, True, True, ..., True] Can_Explode_All = Propagate_Left and Propagate_Right We can use a binary search to find the starting point as well. def findStartLeft(l, r, R): # return True if current R can lead to a chain reaction m = (l + r)/2 if l &lt;= r: if explodePropagateLeft(l): return l else: return -1 if explodePropgateLeft(m): return findStartLeft(m, r, R) else: return findStartLeft(l, m-1, R) def findStartRight(l, r, R): m = (l + r)/2 if l &lt;= r: if explodePropagateRight(l): return l else: return -1 if explodePropgateRight(m): return findStartRight(l, m, R) else: return findStartRight(m+1, r, R) def isValid(l, r, R): return findStartLeft(l, r, R) &lt;= findStartRight(l, r, R) By using nested binary search, the time complexity can be reduced to $O(n\\log{n}\\log{n})$ Time Complexity Analysis With time complexity of $O(n \\log{n}\\log{n})$ and $n &lt; 50,000$, the approximate steps it need is $50,000 \\times 16\\times 16 = 1.3\\times 10^7$ (Consider that we are performing two binary search to determine the existence of starting point, the actual computation step should multiply with factor of $2$, which is approx. $2.6\\times 10^7$), which is an acceptable computational time complexity for Python 3. Problem 2. Radio Contact Link to Question Question Summary Farmer and Bessie are in a two-dimension space with size $1000\\times 1000$. Farmer start at $f_x, f_y$, while Bessie start at $b_x, b_y$. ($0 \\leq f_x, f_y, b_x, b_y \\leq 1000$) Farmer will walk on a path of length $M$, which has “N”, “W”, “E”, “S” in the path and Bessie will walk on a path of length $N$, which has “N”, “W”, “E”, “S” in it. $0 \\leq M, N \\leq 1000$ At each tick, either Farmer or Bessie can choose to stay at current position. A radio that consumes energy of $\\text{Distance}(Farmer, Bessie)^2$ will remain open until both farmer and Bessie finish their path. What is the minimum energy the radio will cost? Proposed Solution This question can be solved using Dynamic Programming. Build up a table with size $M \\times N$ called $E$. $E[m][n]$ represent the minimum energy radio has consumed after farmer takes $m$ moves and Bessie takes $n$ moves. Since the square of distance is always non-negative, either farmer or Bessie (or both) will have to take one step in one tick. Therefore, the result at $E[m][n]$ can be used to calculate $E[m + 1][n]$, $E[m + 1][n + 1]$ and $E[m][n + 1]$, which represent that Bessie stop, no one stop, and Farmer stop, respectively. To start at a specific position, say $E[x][y]$ in the table, we must make sure the value on this position is already the minimum energy, which means that $E[x-1][y]$, $E[x-1][y-1]$, and $E[x][y-1]$ has been calculated. Therefore, we should calculate the whole table from top to down, and in each row from left to right. Time and Space Complexity Analysis Calculating the value of adjacent cell in a table will have a time complexity of $O(1)$, and we will have to calculate each cell inside the table, so the total time complexity will be $O(MN) \\approx O(N^2)$. Since the upper bound of $N$ is only $1\\times 10^3$, we can use Python3 to solve this problem. To store the result for Dynamic Programming (memorization), we have to build a two-dimensional array with size $1000\\times 1000$, and the space complexity should not be a problem. Problem 3. Lights Out Link to Question Question Summary Bessie is on a vertex of a simple polygon with $n$ vertices. The coordinate of vertices are $(x_1, y_1), \\cdots (x_n, y_n)$ listed in a clockwise order. The exit of polygon is located at $(x_1, y_1)$. When the light is out, she forgot which vertex she is on but still remember the whole polygon. By moving clockwise and passing through several edges, she will be able to identify the edge she is on. After she know her position, she will either move clockwise or counter clockwise to get to the nearest exit. The question asks the greatest difference between distance Bessie has to go in dark to exit the polygon and the distance Bessie has to go with lights on to exit the polygon in worst case. Sample Case Explanation Proposed Solution The Problem can be divide into two parts: Help Bessie identify its actual position (calculate the length Bessie has to walk clockwise to identify her position) Calculate the shortest distance between an arbitrary vertex on polygon and the exit. For the first part, we can convert the polygon to a string, where A, B, C and D represents four different types of corners, and integer $m$ represent the length of edge. For example, the polygon in sample can be represented as [\\text{10C1D10A1}] One primitive way to find the shortest unique substring is to maintain a set of pointers, where the pointers represent the starting of one substring that has the same pattern. For instance, suppose we have a string “10C1D10A10C10A”, when Bessie pass by the first edge, she can get information “10C”. At this time, the pointer set will be {0, 8}, since [0:3] and [8:11] are both “10C”. Then, Bessie pass by another edge and get new info “1D”, the pointer set will be reduced to {0}. Since [0 + 3: 0+3+2] is “1D”, while “[8+3: 8+3+2]” is “10”. This will have a time complexity of $O(n^2)$. For the second part, we can store a list $\\text{Dist}$ where $\\text{Dist}[n]$ represent the distance between $n$th vertex and the exit when Bessie moves counterclockwise. Also, we will record the perimeter of whole polygon so that the distance between nth vertex and the exit when Bessie moves clockwise can be calculated using $\\text{Perimeter}-\\text{Dist}[n]$. This has a time complexity of $O(1)$. Since we $n$ vertexes to go through, the total time complexity will be $O(n^3)$. Time Complexity Analysis $4\\leq N\\leq 200$, so time complexity of $O(n^3)$ will only lead to a computational step of at most $1.6\\times 10^7$ steps, and this problem can be solved by Python3 with the proposed solution.","headline":"USACO 2016 Jan Gold Analysis","mainEntityOfPage":{"@type":"WebPage","@id":"https://markchenyutian.github.io//blog/2020/USACO-2016-Jan-Gold-Analysis.html"},"url":"https://markchenyutian.github.io//blog/2020/USACO-2016-Jan-Gold-Analysis.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/blog/assets/css/main.css">
  <script src="/blog/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://markchenyutian.github.io//blog/feed.xml" title="Yutian's Blog">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      skipTags:['script', 'noscript', 'style', 'textarea', 'pre'],
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>



















<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<!-- | default: default_paths - --><span class="site-brand"><a class="site-brand-inner" rel="author" href="/blog/">
  <img class="site-favicon" title="Yutian's Blog" src="" onerror="this.style.display='none'">
  Yutian's Blog
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/blog/about.html">ABOUT</a><a class="page-link" href="/blog/posts.html">POSTS</a><a class="page-link" href="/blog/files.html">FILES</a>




<span class="page-link">

<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="Franch">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: '',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>










































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">USACO 2016 Jan Gold Analysis</h1>
  <h3 class="post-subtitle"></h3>

  <p class="post-meta">
    <time class="dt-published" datetime="2020-10-04T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Oct 04, 2020
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 26 mins</span>

    <!-- Read Count Insert Here -->
  </p>
<div class="post-tags"><a class="post-tag" href="/blog/tags.html#Algorithm">#Algorithm</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="problem-1-angry-cows">Problem 1. Angry Cows</h2>

<h3 id="question-summary">Question Summary</h3>

<p><a href="http://usaco.org/index.php?page=viewproblem2&cpid=597">Link to Question</a></p>

<p>The $N$ hey are on a line, with position $x_1, x_2, \cdots, x_N$. If the cow is shoot to position $x$ with force $R$, then all the cows in range $x \pm R$ will explode. The hey exploded will have a range of $x’ \pm (R - 1)$, the second round of hey exploded will have a range of $x’’ \pm (R-2)$, and so on.</p>

<p>The question requires the <strong>minimum</strong> power $R$ with one-decimal accuracy that will let all hey on the line explode.
$$
2 \leq N \leq 50,000 \quad \quad \quad \forall n, 0 \leq x_n \leq 1,000,000
$$</p>

<h3 id="proposed-solution">Proposed Solution</h3>

<p><strong>Binary Search</strong></p>

<p>There exists an $r’$ such that for all $R&gt;r’$  , all the hey on the line will explode, so it is possible to use binary search in this question.</p>

<p>Storing all the positions $x_1$ to $x_n$ in a list, we can construct two pointers that represents the “frontier” of explosion.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">xn</span><span class="p">]</span>
<span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>
</code></pre></div></div>

<p>For each explosion, we can use a time complexity of $O(1)$ to update the pointer’s position.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">updatePosition</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">positions</span><span class="p">[</span><span class="n">p1</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>
        <span class="n">p1</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">positions</span><span class="p">[</span><span class="n">p2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">positions</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">:</span>
        <span class="n">p2</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">R</span> <span class="o">-</span> <span class="mi">1</span>
</code></pre></div></div>

<p>Therefore, it will take time of $O(n)$ for us to simulate one case.</p>

<p><em>One optimization is to stop the simulation immediately and return <code class="language-plaintext highlighter-rouge">false</code> if the chain reaction stop</em></p>

<p>If we try all the possible starting point, the total time complexity will be $O(n^2\log{n})$ and it will lead to TLE for Python.</p>

<p>Noticing for all possible starting points, given a fixed force $R$, if starting at $x_i$ can lead a chain reaction that explode all, we note as <code class="language-plaintext highlighter-rouge">true</code>, otherwise, <code class="language-plaintext highlighter-rouge">false</code>, the resulting simulation result should look like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Propagate_Leftward: [True, True, ..., True, True, True, False, ..., False]
Propagate_Rightward: [False, False, ..., False, True, True, ..., True]
Can_Explode_All = Propagate_Left and Propagate_Right
</code></pre></div></div>

<p>We can use a binary search to find the starting point as well.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">findStartLeft</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="c1"># return True if current R can lead to a chain reaction
</span>    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">explodePropagateLeft</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="k">return</span> <span class="n">l</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">explodePropgateLeft</span><span class="p">(</span><span class="n">m</span><span class="p">):</span> <span class="k">return</span> <span class="n">findStartLeft</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">findStartLeft</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">findStartRight</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">explodePropagateRight</span><span class="p">(</span><span class="n">l</span><span class="p">):</span> <span class="k">return</span> <span class="n">l</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">explodePropgateRight</span><span class="p">(</span><span class="n">m</span><span class="p">):</span> <span class="k">return</span> <span class="n">findStartRight</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">findStartRight</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">findStartLeft</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">findStartRight</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
</code></pre></div></div>

<p>By using nested binary search, the time complexity can be reduced to $O(n\log{n}\log{n})$</p>

<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>

<p>With time complexity of $O(n \log{n}\log{n})$ and $n &lt; 50,000$, the approximate steps it need is $50,000 \times 16\times 16 = 1.3\times 10^7$ (Consider that we are performing two binary search to determine the existence of starting point, the actual computation step should multiply with factor of $2$, which is approx. $2.6\times 10^7$), which is an acceptable computational time complexity for Python 3.</p>

<hr>

<h2 id="problem-2-radio-contact">Problem 2. Radio Contact</h2>

<p><a href="http://usaco.org/index.php?page=viewproblem2&cpid=598">Link to Question</a></p>

<h3 id="question-summary-1">Question Summary</h3>

<p>Farmer and Bessie are in a two-dimension space with size $1000\times 1000$. Farmer start at $f_x, f_y$, while Bessie start at $b_x, b_y$. ($0 \leq f_x, f_y, b_x, b_y \leq 1000$)</p>

<p>Farmer will walk on a path of length $M$, which has “N”, “W”, “E”, “S” in the path and Bessie will walk on a path of length $N$, which has “N”, “W”, “E”, “S” in it. $0 \leq M, N \leq 1000$</p>

<p>At each tick, either Farmer or Bessie can choose to stay at current position. A radio that consumes energy of $\text{Distance}(Farmer, Bessie)^2$  will remain open until both farmer and Bessie finish their path. <strong>What is the minimum energy the radio will cost</strong>?</p>

<h3 id="proposed-solution-1">Proposed Solution</h3>

<p>This question can be solved using Dynamic Programming.</p>

<p>Build up a table with size $M \times N$ called $E$. $E[m][n]$ represent the <strong>minimum energy radio has consumed</strong> after farmer takes $m$ moves and Bessie takes $n$ moves. Since the square of distance is always non-negative, either farmer or Bessie (or both) will have to take one step in one tick. Therefore, the result at $E[m][n]$ can be used to calculate $E[m + 1][n]$, $E[m  + 1][n + 1]$ and $E[m][n + 1]$, which represent that Bessie stop, no one stop, and Farmer stop, respectively.</p>

<p>To start at a specific position, say $E[x][y]$ in the table, we must make sure the value on this position is already the minimum energy, which means that $E[x-1][y]$, $E[x-1][y-1]$, and $E[x][y-1]$ has been calculated. Therefore, we should calculate the whole table from top to down, and in each row from left to right.</p>

<h3 id="time-and-space-complexity-analysis">Time and Space Complexity Analysis</h3>

<p>Calculating the value of adjacent cell in a table will have a time complexity of $O(1)$, and we will have to calculate each cell inside the table, so the total time complexity will be $O(MN) \approx O(N^2)$. Since the upper bound of $N$ is only $1\times 10^3$, we can use Python3 to solve this problem.</p>

<p>To store the result for Dynamic Programming (memorization), we have to build a two-dimensional array with size $1000\times 1000$, and the space complexity should not be a problem.</p>

<hr>

<h2 id="problem-3-lights-out">Problem 3. Lights Out</h2>

<p><a href="http://usaco.org/index.php?page=viewproblem2&cpid=599">Link to Question</a></p>

<h3 id="question-summary-2">Question Summary</h3>

<p>Bessie is on a vertex of a simple polygon with $n$ vertices. The coordinate of vertices are $(x_1, y_1), \cdots (x_n, y_n)$ listed in a clockwise order. The exit of polygon is located at $(x_1, y_1)$. When the light is out, she forgot which vertex she is on but still remember the whole polygon. By moving clockwise and passing through several edges, she will be able to identify the edge she is on. After she know her position, she will either move clockwise or counter clockwise to get to the nearest exit.</p>

<p>The question asks the <strong>greatest difference</strong> between distance Bessie has to go in dark to exit the polygon and the distance Bessie has to go with lights on to exit the polygon in worst case.</p>

<h3 id="sample-case-explanation">Sample Case Explanation</h3>

<p><img src="https://markchenyutian.github.io/Markchen_Blog/Asset/USACO2016JanGold3_1.png" alt="image"></p>

<h3 id="proposed-solution-2">Proposed Solution</h3>

<p>The Problem can be divide into two parts:</p>

<ol>
  <li>Help Bessie identify its actual position (calculate the length Bessie has to walk clockwise to identify her position)</li>
  <li>Calculate the shortest distance between an arbitrary vertex on polygon and the exit.</li>
</ol>

<p>For the <strong>first</strong> part, we can convert the polygon to a string, where A, B, C and D represents four different types of corners, and integer $m$ represent the length of edge.</p>

<p><img src="https://markchenyutian.github.io/Markchen_Blog/Asset/USACO2016_Jan_Gold3-2.jpg" alt="image2" style="zoom: 33%;"></p>

<p>For example, the polygon in sample can be represented as</p>

<p>$$
\text{10C1D10A1}
$$</p>

<p>One primitive way to find the shortest unique substring is to maintain a set of pointers, where the pointers represent the starting of one substring that has the same pattern.</p>

<blockquote>
  <p>For instance, suppose we have a string “10C1D10A10C10A”, when Bessie pass by the first edge, she can get information “10C”. At this time, the pointer set will be {0, 8}, since [0:3] and [8:11] are both “10C”.</p>

  <p>Then, Bessie pass by another edge and get new info “1D”,  the pointer set will be reduced to {0}. Since [0 + 3: 0+3+2] is “1D”, while “[8+3: 8+3+2]” is “10”.</p>
</blockquote>

<p>This will have a time complexity of $O(n^2)$.</p>

<p>For the <strong>second</strong> part, we can store a list $\text{Dist}$  where $\text{Dist}[n]$ represent the distance between $n$th vertex and the exit when Bessie moves counterclockwise. Also, we will record the perimeter of whole polygon so that the distance between nth vertex and the exit when Bessie moves clockwise can be calculated using $\text{Perimeter}-\text{Dist}[n]$. This has a time complexity of $O(1)$.</p>

<p>Since we $n$ vertexes to go through, the total time complexity will be $O(n^3)$.</p>

<h3 id="time-complexity-analysis-1">Time Complexity Analysis</h3>

<p>$4\leq N\leq 200$, so time complexity of $O(n^3)$ will only lead to a computational step of at most $1.6\times 10^7$ steps, and this problem can be solved by Python3 with the proposed solution.</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/blog/2020/Gradient-Descent-Methods.html" title="深度学习的梯度下降方法">深度学习的梯度下降方法</a><a class="next" href="/blog/2020/USACO-2016-Feb-Gold-Analysis.html" title="USACO 2016 Feb Gold Analysis">USACO 2016 Feb Gold Analysis</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <!-- <ul>
        
        <li><a class="post-link" href="/blog/2022/Multi-heuristic-Astar.html" title="USACO 2016 Feb Gold Analysis">A* Search and its Variants</a></li><li><a class="post-link" href="/blog/2021/Seq2Seq.html" title="USACO 2016 Feb Gold Analysis">NLP 101: Seq2Seq 模型</a></li><li><a class="post-link" href="/blog/2022/clac-embeddable.html" title="USACO 2016 Feb Gold Analysis">Embeddable Clac Execution Environment</a></li><li><a class="post-link" href="/blog/2022/serverless-file-system.html" title="USACO 2016 Feb Gold Analysis">Serverless File System based on AWS S3</a></li></ul> -->
      
      
      
      <ul>
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/2D-Prefix-Sum.html" title="USACO 2016 Feb Gold Analysis">二维前缀和 2D Prefix Sum</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/Segment-Tree.html" title="USACO 2016 Feb Gold Analysis">线段树 Segment Tree</a></li>
            
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2020/USACO-2017-Dec-Gold.html" title="USACO 2016 Feb Gold Analysis">USACO 2017 Dec Gold Analysis</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2020/USACO-2017-Feb-Gold.html" title="USACO 2016 Feb Gold Analysis">USACO 2017 Feb Gold Analysis</a></li>
            
          
          
      </ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">目录</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      if (! h.getAttribute('hide-toc')){
        menuHTML += (
          '<li class="h-' + h.tagName.toLowerCase() + '">'
          + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
        }
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2019-2022 @Yutian (Mark) Chen</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/blog/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
