<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--<meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c"></meta>--><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>USACO 2016 Dec Gold Analysis | Yutian’s Blog</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="USACO 2016 Dec Gold Analysis">
<meta name="author" content="Yutian (Mark) Chen">
<meta property="og:locale" content="en_US">
<meta name="description" content="Problem 1 Moo-cast Problem Summary Cows want to communicate with each other by walkie-talkies. It is known that a walkie-talkie that costs $X$ dollars will have a broadcast radius of $\sqrt{X}$. Given the location of all the cows in the form of $(x, y)$ coordinate, what is the minimum cost to buy walkie-talkie such that every cow can communicate with each other (may not be directly but through several ‘hops’). Proposed Solution Basically, what we want to find in this question is the greatest shortest distance between different points. For each point, we have a shortest distance that connect to other points. The amount of money required is the greatest ‘shortest distance’. However, this question requires more than this, since linking each point with the nearest point may lead to several subgraphs that are not connected between each other. Therefore, we can simply traverse all the possible point pair and calculate their distance square if they are not in the same graph. Below is a draft of code Points = [(x1, y1), (x2, y2), ..., (xn, yn)] X = -1 for p1 in range (len(Points)): a = Points[p1] for p2 in range (p1 + 1, len(Points)): b = Points[p2] if not InSameGraph(a, b): X = max(X, math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2) return X The function InSameGraph can be implemented by storing all the points in a UFDS. With appropriate path compression methods, the time complexity of InSameGraph can be bound to approx. $O(\log{n})$. Time Complexity Analysis This proposed algorithm has a time complexity of $O(n^2\log{n})$. Since the number of point $n$ in the question is no more than 1000, the computational step of this proposed solution should be no more than $1\times 10^7$, which means that it will not use more than 4 sec to run. Problem 2. Cow Checklist Problem Summary There are two types of cows, noted as type H and type G. There are $H$ cows that are type H and $G$ cows that are type G. However, John must access all the cows of type H in order from 1 to $H$, and access all the cows of type G in order from 1 to $G$. The position of all cows are given as x-y coordinate, moving distance $d$ will cost the energy of $d^2$, what is the minimum energy consumption for John to access all cows. Proposed Solution We can use dynamic programming to solve this problem. Let $E[0][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at H-type cow. $E[1][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at G-type cow. Then, we can use this function to calculate through the whole table. \(E[0][h + 1][g] = \min(E[1][h][g]+Dist(G_g, H_{h+1})^2,\, E[0][h][g] + Dist(H_h, H_{h+1})^2)\) [E[0][h][g+1] = \min(E[1][h][g]+Dist(G_g, G_{g+1})^2,\, E[0][h][g] + Dist(H_h, G_{g+1})^2)] … (the equation for another 2 situations are omitted) By doing so, we can calculate the result of $E[0][H][G]$, which will be the final result (since John have to end his walk at a H-type cow). Time Complexity Analysis Since calculating one number in the table will have a time complexity of $O(1)$, the total time complexity will be $O(HG)$. Because $1\leq H\leq 1000$ and $1 \leq G \leq 1000$, the algorithm will require at most $1\times 10^7$ steps, and it is possible for Python 3 to run in 4 sec. Problem 3. Lasers and Mirrors Problem Summary Cows want to direct a laser to the barn. However, they can’t move the laser generator. Therefore, they decide to install a set of mirrors that will change the direction of laser on the fence post. Given the position of laser generator, barn, and fence posts, the output will be the minimum amount of reflection the laser has to pass to arrive at the barn. Proposed Solution Basically, we can see each post on the field as two different lines, one horizontal and one vertical. Each post can help us to move from a horizontal line to vertical line (and vice versa). We can use a breadth first search (BFS) directly here. Since the property of BFS makes sure the first path found is the shortest path, we will break out the loop as long as we found path. The pseudocode will be like this: # Line is noted as (coordinate, horizontal?, reflectTime) fringe = LinkList() fringe.append((x1, True, 0), (y1, False, 0)) exploredEdge = set() result = -1 while len(fringe) &gt; 0: currEdge = fringe.pop() if (currEdge[0], currEdge[1]) in exploredEdge: continue exploredEdge.add((currEdge[0], currEdge[1])) if isResult(currEdge): result = currEdge[2] for newEdge in getTransitionEdge(currEdge): fringe.add((newEdge[0], not newEdge[1], currEdge[2] + 1)) # changing edge means the laser has been reflected for one more time, also, the direction will be (must be) changed after reflection print(result) Since there are $1\times 10^5$ posts, the time complexity should be at most $O(n \log{n})$. Since the BFS itself will have a time complexity of $O(n)$, we must implement isResult and getTransitionEdge functions with time complexity of $O(\log n)$. Here are the ways to implement these two functions: isResult - if the line is horizontal and its $y$ value equals to $y_2$ or the line is vertical and its $x$ value equals to $x_2$, the line will pass through the destination. This operation can be done in $O(1)$. getTransitionEdge - Here, we need two different dictionaries to help us. One dictionary use the x-coordinate of line as key, and value is a list of y-coordinates. Another dictionary use the y-coordinate of line as key, and value is a list of x-coordinates. When we are on a horizontal line, we will use the y -&gt; x dictionary. When we are on a vertical line, we will use the x -&gt; y dictionary. This operation can be done in $O(m)$, where $m$ is the number of values in one key. Time Complexity Analysis The total time complexity of this proposed solution is $O(mn)$, where $m$ is the Maximum number of posts on one line, and $n$ is the total number of posts. There do exist some extreme case where $m\approx n$. Under such case, however, the time complexity of BFS will be greatly decreasing, since the depth of tree will decrease drastically. Therefore, this program will be able to give out solution in less than 4 sec for most of the cases.">
<meta property="og:description" content="Problem 1 Moo-cast Problem Summary Cows want to communicate with each other by walkie-talkies. It is known that a walkie-talkie that costs $X$ dollars will have a broadcast radius of $\sqrt{X}$. Given the location of all the cows in the form of $(x, y)$ coordinate, what is the minimum cost to buy walkie-talkie such that every cow can communicate with each other (may not be directly but through several ‘hops’). Proposed Solution Basically, what we want to find in this question is the greatest shortest distance between different points. For each point, we have a shortest distance that connect to other points. The amount of money required is the greatest ‘shortest distance’. However, this question requires more than this, since linking each point with the nearest point may lead to several subgraphs that are not connected between each other. Therefore, we can simply traverse all the possible point pair and calculate their distance square if they are not in the same graph. Below is a draft of code Points = [(x1, y1), (x2, y2), ..., (xn, yn)] X = -1 for p1 in range (len(Points)): a = Points[p1] for p2 in range (p1 + 1, len(Points)): b = Points[p2] if not InSameGraph(a, b): X = max(X, math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2) return X The function InSameGraph can be implemented by storing all the points in a UFDS. With appropriate path compression methods, the time complexity of InSameGraph can be bound to approx. $O(\log{n})$. Time Complexity Analysis This proposed algorithm has a time complexity of $O(n^2\log{n})$. Since the number of point $n$ in the question is no more than 1000, the computational step of this proposed solution should be no more than $1\times 10^7$, which means that it will not use more than 4 sec to run. Problem 2. Cow Checklist Problem Summary There are two types of cows, noted as type H and type G. There are $H$ cows that are type H and $G$ cows that are type G. However, John must access all the cows of type H in order from 1 to $H$, and access all the cows of type G in order from 1 to $G$. The position of all cows are given as x-y coordinate, moving distance $d$ will cost the energy of $d^2$, what is the minimum energy consumption for John to access all cows. Proposed Solution We can use dynamic programming to solve this problem. Let $E[0][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at H-type cow. $E[1][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at G-type cow. Then, we can use this function to calculate through the whole table. \(E[0][h + 1][g] = \min(E[1][h][g]+Dist(G_g, H_{h+1})^2,\, E[0][h][g] + Dist(H_h, H_{h+1})^2)\) [E[0][h][g+1] = \min(E[1][h][g]+Dist(G_g, G_{g+1})^2,\, E[0][h][g] + Dist(H_h, G_{g+1})^2)] … (the equation for another 2 situations are omitted) By doing so, we can calculate the result of $E[0][H][G]$, which will be the final result (since John have to end his walk at a H-type cow). Time Complexity Analysis Since calculating one number in the table will have a time complexity of $O(1)$, the total time complexity will be $O(HG)$. Because $1\leq H\leq 1000$ and $1 \leq G \leq 1000$, the algorithm will require at most $1\times 10^7$ steps, and it is possible for Python 3 to run in 4 sec. Problem 3. Lasers and Mirrors Problem Summary Cows want to direct a laser to the barn. However, they can’t move the laser generator. Therefore, they decide to install a set of mirrors that will change the direction of laser on the fence post. Given the position of laser generator, barn, and fence posts, the output will be the minimum amount of reflection the laser has to pass to arrive at the barn. Proposed Solution Basically, we can see each post on the field as two different lines, one horizontal and one vertical. Each post can help us to move from a horizontal line to vertical line (and vice versa). We can use a breadth first search (BFS) directly here. Since the property of BFS makes sure the first path found is the shortest path, we will break out the loop as long as we found path. The pseudocode will be like this: # Line is noted as (coordinate, horizontal?, reflectTime) fringe = LinkList() fringe.append((x1, True, 0), (y1, False, 0)) exploredEdge = set() result = -1 while len(fringe) &gt; 0: currEdge = fringe.pop() if (currEdge[0], currEdge[1]) in exploredEdge: continue exploredEdge.add((currEdge[0], currEdge[1])) if isResult(currEdge): result = currEdge[2] for newEdge in getTransitionEdge(currEdge): fringe.add((newEdge[0], not newEdge[1], currEdge[2] + 1)) # changing edge means the laser has been reflected for one more time, also, the direction will be (must be) changed after reflection print(result) Since there are $1\times 10^5$ posts, the time complexity should be at most $O(n \log{n})$. Since the BFS itself will have a time complexity of $O(n)$, we must implement isResult and getTransitionEdge functions with time complexity of $O(\log n)$. Here are the ways to implement these two functions: isResult - if the line is horizontal and its $y$ value equals to $y_2$ or the line is vertical and its $x$ value equals to $x_2$, the line will pass through the destination. This operation can be done in $O(1)$. getTransitionEdge - Here, we need two different dictionaries to help us. One dictionary use the x-coordinate of line as key, and value is a list of y-coordinates. Another dictionary use the y-coordinate of line as key, and value is a list of x-coordinates. When we are on a horizontal line, we will use the y -&gt; x dictionary. When we are on a vertical line, we will use the x -&gt; y dictionary. This operation can be done in $O(m)$, where $m$ is the number of values in one key. Time Complexity Analysis The total time complexity of this proposed solution is $O(mn)$, where $m$ is the Maximum number of posts on one line, and $n$ is the total number of posts. There do exist some extreme case where $m\approx n$. Under such case, however, the time complexity of BFS will be greatly decreasing, since the depth of tree will decrease drastically. Therefore, this program will be able to give out solution in less than 4 sec for most of the cases.">
<link rel="canonical" href="https://markchenyutian.github.io//blog/2020/USACO-2016-Dec-Gold.html">
<meta property="og:url" content="https://markchenyutian.github.io//blog/2020/USACO-2016-Dec-Gold.html">
<meta property="og:site_name" content="Yutian’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-11-06T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="USACO 2016 Dec Gold Analysis">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yutian (Mark) Chen"},"dateModified":"2020-11-06T00:00:00+00:00","datePublished":"2020-11-06T00:00:00+00:00","description":"Problem 1 Moo-cast Problem Summary Cows want to communicate with each other by walkie-talkies. It is known that a walkie-talkie that costs $X$ dollars will have a broadcast radius of $\\sqrt{X}$. Given the location of all the cows in the form of $(x, y)$ coordinate, what is the minimum cost to buy walkie-talkie such that every cow can communicate with each other (may not be directly but through several ‘hops’). Proposed Solution Basically, what we want to find in this question is the greatest shortest distance between different points. For each point, we have a shortest distance that connect to other points. The amount of money required is the greatest ‘shortest distance’. However, this question requires more than this, since linking each point with the nearest point may lead to several subgraphs that are not connected between each other. Therefore, we can simply traverse all the possible point pair and calculate their distance square if they are not in the same graph. Below is a draft of code Points = [(x1, y1), (x2, y2), ..., (xn, yn)] X = -1 for p1 in range (len(Points)): a = Points[p1] for p2 in range (p1 + 1, len(Points)): b = Points[p2] if not InSameGraph(a, b): X = max(X, math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2) return X The function InSameGraph can be implemented by storing all the points in a UFDS. With appropriate path compression methods, the time complexity of InSameGraph can be bound to approx. $O(\\log{n})$. Time Complexity Analysis This proposed algorithm has a time complexity of $O(n^2\\log{n})$. Since the number of point $n$ in the question is no more than 1000, the computational step of this proposed solution should be no more than $1\\times 10^7$, which means that it will not use more than 4 sec to run. Problem 2. Cow Checklist Problem Summary There are two types of cows, noted as type H and type G. There are $H$ cows that are type H and $G$ cows that are type G. However, John must access all the cows of type H in order from 1 to $H$, and access all the cows of type G in order from 1 to $G$. The position of all cows are given as x-y coordinate, moving distance $d$ will cost the energy of $d^2$, what is the minimum energy consumption for John to access all cows. Proposed Solution We can use dynamic programming to solve this problem. Let $E[0][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at H-type cow. $E[1][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at G-type cow. Then, we can use this function to calculate through the whole table. \\(E[0][h + 1][g] = \\min(E[1][h][g]+Dist(G_g, H_{h+1})^2,\\, E[0][h][g] + Dist(H_h, H_{h+1})^2)\\) [E[0][h][g+1] = \\min(E[1][h][g]+Dist(G_g, G_{g+1})^2,\\, E[0][h][g] + Dist(H_h, G_{g+1})^2)] … (the equation for another 2 situations are omitted) By doing so, we can calculate the result of $E[0][H][G]$, which will be the final result (since John have to end his walk at a H-type cow). Time Complexity Analysis Since calculating one number in the table will have a time complexity of $O(1)$, the total time complexity will be $O(HG)$. Because $1\\leq H\\leq 1000$ and $1 \\leq G \\leq 1000$, the algorithm will require at most $1\\times 10^7$ steps, and it is possible for Python 3 to run in 4 sec. Problem 3. Lasers and Mirrors Problem Summary Cows want to direct a laser to the barn. However, they can’t move the laser generator. Therefore, they decide to install a set of mirrors that will change the direction of laser on the fence post. Given the position of laser generator, barn, and fence posts, the output will be the minimum amount of reflection the laser has to pass to arrive at the barn. Proposed Solution Basically, we can see each post on the field as two different lines, one horizontal and one vertical. Each post can help us to move from a horizontal line to vertical line (and vice versa). We can use a breadth first search (BFS) directly here. Since the property of BFS makes sure the first path found is the shortest path, we will break out the loop as long as we found path. The pseudocode will be like this: # Line is noted as (coordinate, horizontal?, reflectTime) fringe = LinkList() fringe.append((x1, True, 0), (y1, False, 0)) exploredEdge = set() result = -1 while len(fringe) &gt; 0: currEdge = fringe.pop() if (currEdge[0], currEdge[1]) in exploredEdge: continue exploredEdge.add((currEdge[0], currEdge[1])) if isResult(currEdge): result = currEdge[2] for newEdge in getTransitionEdge(currEdge): fringe.add((newEdge[0], not newEdge[1], currEdge[2] + 1)) # changing edge means the laser has been reflected for one more time, also, the direction will be (must be) changed after reflection print(result) Since there are $1\\times 10^5$ posts, the time complexity should be at most $O(n \\log{n})$. Since the BFS itself will have a time complexity of $O(n)$, we must implement isResult and getTransitionEdge functions with time complexity of $O(\\log n)$. Here are the ways to implement these two functions: isResult - if the line is horizontal and its $y$ value equals to $y_2$ or the line is vertical and its $x$ value equals to $x_2$, the line will pass through the destination. This operation can be done in $O(1)$. getTransitionEdge - Here, we need two different dictionaries to help us. One dictionary use the x-coordinate of line as key, and value is a list of y-coordinates. Another dictionary use the y-coordinate of line as key, and value is a list of x-coordinates. When we are on a horizontal line, we will use the y -&gt; x dictionary. When we are on a vertical line, we will use the x -&gt; y dictionary. This operation can be done in $O(m)$, where $m$ is the number of values in one key. Time Complexity Analysis The total time complexity of this proposed solution is $O(mn)$, where $m$ is the Maximum number of posts on one line, and $n$ is the total number of posts. There do exist some extreme case where $m\\approx n$. Under such case, however, the time complexity of BFS will be greatly decreasing, since the depth of tree will decrease drastically. Therefore, this program will be able to give out solution in less than 4 sec for most of the cases.","headline":"USACO 2016 Dec Gold Analysis","mainEntityOfPage":{"@type":"WebPage","@id":"https://markchenyutian.github.io//blog/2020/USACO-2016-Dec-Gold.html"},"url":"https://markchenyutian.github.io//blog/2020/USACO-2016-Dec-Gold.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/blog/assets/css/main.css">
  <script src="/blog/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://markchenyutian.github.io//blog/feed.xml" title="Yutian's Blog">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      skipTags:['script', 'noscript', 'style', 'textarea', 'pre'],
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>



















<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<!-- | default: default_paths - --><span class="site-brand"><a class="site-brand-inner" rel="author" href="/blog/">
  <img class="site-favicon" title="Yutian's Blog" src="" onerror="this.style.display='none'">
  Yutian's Blog
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/blog/about.html">ABOUT</a><a class="page-link" href="/blog/posts.html">POSTS</a><a class="page-link" href="/blog/files.html">FILES</a>




<span class="page-link">

<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="Franch">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: '',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>










































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">USACO 2016 Dec Gold Analysis</h1>
  <h3 class="post-subtitle"></h3>

  <p class="post-meta">
    <time class="dt-published" datetime="2020-11-06T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 06, 2020
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 21 mins</span>

    <!-- Read Count Insert Here -->
  </p>
<div class="post-tags"><a class="post-tag" href="/blog/tags.html#Algorithm">#Algorithm</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="problem-1-moo-cast">Problem 1 Moo-cast</h2>

<h3 id="problem-summary">Problem Summary</h3>

<p>Cows want to  communicate with each other by walkie-talkies. It is known that a walkie-talkie that costs $X$ dollars will have a broadcast radius of $\sqrt{X}$. Given the location of all the cows in the form of $(x, y)$ coordinate, what is the minimum cost to buy walkie-talkie such that every cow can communicate with each other (may not be directly but through several ‘hops’).</p>

<h3 id="proposed-solution">Proposed Solution</h3>

<p>Basically, what we want to find in this question is the greatest shortest distance between different points. For each point, we have a shortest distance that connect to other points. The amount of money required is the greatest ‘shortest distance’.</p>

<p><strong>However, this question requires more than this, since linking each point with the nearest point may lead to several subgraphs that are not connected between each other</strong>.</p>

<p>Therefore, we can simply traverse all the possible point pair and calculate their distance square if they are not in the same graph. Below is a draft of code</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">),</span> <span class="p">...,</span> <span class="p">(</span><span class="n">xn</span><span class="p">,</span> <span class="n">yn</span><span class="p">)]</span>
<span class="n">X</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">)):</span>
	<span class="n">a</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="n">p1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Points</span><span class="p">)):</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">Points</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">InSameGraph</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
			<span class="n">X</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">math</span><span class="p">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="k">return</span> <span class="n">X</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">InSameGraph</code> can be implemented by storing all the points in a UFDS. With appropriate path compression methods, the time complexity of <code class="language-plaintext highlighter-rouge">InSameGraph</code> can be bound to approx. $O(\log{n})$.</p>

<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>

<p>This proposed algorithm has a time complexity of $O(n^2\log{n})$. Since the number of point $n$ in the question is no more than 1000, the computational step of this proposed solution should be no more than $1\times 10^7$, which means that it will not  use more than 4 sec to run.</p>

<h2 id="problem-2-cow-checklist">Problem 2. Cow Checklist</h2>

<h3 id="problem-summary-1">Problem Summary</h3>

<p>There are two types of cows, noted as type H and type G. There are $H$ cows that are type H and $G$ cows that are type G. However, John must access all the cows of type H in order from 1 to $H$, and access all the cows of type G in order from 1 to $G$.</p>

<p>The position of all cows are given as x-y coordinate, moving distance $d$ will cost the energy of $d^2$, what is the minimum energy consumption for John to access all cows.</p>

<h3 id="proposed-solution-1">Proposed Solution</h3>

<p>We can use dynamic programming to solve this problem. Let $E[0][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at H-type cow. $E[1][h][g]$ represent the minimum energy John has to consume to visit $h$ H-type cows, $g$ G-type cows, and finally stop at G-type cow.</p>

<p>Then, we can use this function to calculate through the whole table.
$$
E[0][h + 1][g] = \min(E[1][h][g]+Dist(G_g, H_{h+1})^2,\, E[0][h][g] + Dist(H_h, H_{h+1})^2)
$$</p>

<p>$$
E[0][h][g+1] = \min(E[1][h][g]+Dist(G_g, G_{g+1})^2,\, E[0][h][g] + Dist(H_h, G_{g+1})^2)
$$</p>

<p>… (the equation for another 2 situations are omitted)</p>

<p>By doing so, we can calculate the result of $E[0][H][G]$, which will be the final result (since John have to end his walk at a H-type cow).</p>

<h3 id="time-complexity-analysis-1">Time Complexity Analysis</h3>

<p>Since calculating one number in the table will have a time complexity of $O(1)$, the total time complexity will be $O(HG)$. Because $1\leq H\leq 1000$ and $1 \leq G \leq 1000$, the algorithm will require at most $1\times 10^7$ steps, and it is possible for Python 3 to run in 4 sec.</p>

<h2 id="problem-3-lasers-and-mirrors">Problem 3. Lasers and Mirrors</h2>

<h3 id="problem-summary-2">Problem Summary</h3>

<p>Cows want to direct a laser to the barn. However, they can’t move the laser generator. Therefore, they decide to install a set of mirrors that will change the direction of laser on the fence post. Given the position of laser generator, barn, and fence posts, the output will be the <strong>minimum</strong> amount of reflection  the laser has to pass to arrive at the barn.</p>

<h3 id="proposed-solution-2">Proposed Solution</h3>

<p>Basically, we can see each post on the field as two different lines, one horizontal and one vertical. Each post can help us to move from a horizontal line to vertical line (and vice versa).</p>

<p>We can use a <em>breadth first search</em> (BFS) directly here. Since the property of BFS makes sure the first path found is the shortest path, we will break out the loop as long as we found path. The pseudocode will be like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Line is noted as (coordinate, horizontal?, reflectTime)
</span><span class="n">fringe</span> <span class="o">=</span> <span class="n">LinkList</span><span class="p">()</span>
<span class="n">fringe</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">exploredEdge</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">fringe</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">currEdge</span> <span class="o">=</span> <span class="n">fringe</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">currEdge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">currEdge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="ow">in</span> <span class="n">exploredEdge</span><span class="p">:</span> <span class="k">continue</span>
   	<span class="n">exploredEdge</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">currEdge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">currEdge</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">isResult</span><span class="p">(</span><span class="n">currEdge</span><span class="p">):</span> <span class="n">result</span> <span class="o">=</span> <span class="n">currEdge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">newEdge</span> <span class="ow">in</span> <span class="n">getTransitionEdge</span><span class="p">(</span><span class="n">currEdge</span><span class="p">):</span>
        <span class="n">fringe</span><span class="p">.</span><span class="n">add</span><span class="p">((</span><span class="n">newEdge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="ow">not</span> <span class="n">newEdge</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">currEdge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="c1"># changing edge means the laser has been reflected for one more time, also, the direction will be (must be) changed after reflection
</span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre></div></div>

<p>Since there are $1\times 10^5$ posts, the time complexity should be at most $O(n \log{n})$. Since the BFS itself will have a time complexity of $O(n)$, we must implement <code class="language-plaintext highlighter-rouge">isResult</code> and <code class="language-plaintext highlighter-rouge">getTransitionEdge</code> functions with time complexity of $O(\log n)$.</p>

<p>Here are the ways to implement these two functions:</p>

<p><code class="language-plaintext highlighter-rouge">isResult</code> - if the line is horizontal and its $y$ value equals to $y_2$ or the line is vertical and its $x$ value equals to $x_2$, the line will pass through the destination. This operation can be done in $O(1)$.</p>

<p><code class="language-plaintext highlighter-rouge">getTransitionEdge</code> - Here, we need two different dictionaries to help us. One dictionary use the <em>x-coordinate</em> of line as key, and value is a list of <em>y-coordinates</em>. Another dictionary use the <em>y-coordinate</em> of line as key, and value is a list of <em>x-coordinates</em>. When we are on a horizontal line, we will use the y -&gt; x dictionary. When we are on a vertical line, we will use the x -&gt; y dictionary. This operation can be done in $O(m)$, where $m$ is the number of values in one key.</p>

<h3 id="time-complexity-analysis-2">Time Complexity Analysis</h3>

<p>The total time complexity of this proposed solution is $O(mn)$, where $m$ is the <em>Maximum number of posts on one line</em>, and $n$ is the total number of posts. <strong>There do exist some extreme case where $m\approx n$.</strong> Under such case, however, the time complexity of BFS will be greatly decreasing, since the depth of tree will decrease drastically.</p>

<p>Therefore, this program will be able to give out solution in less than 4 sec for most of the cases.</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/blog/2020/Elliptical-Curve-Signature.html" title="Elliptical Curve Signature Algorithm">Elliptical Curve Signature Algorithm</a><a class="next" href="/blog/2020/USACO-2017-Jan-Gold.html" title="USACO 2017 Jan Gold Analysis">USACO 2017 Jan Gold Analysis</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <!-- <ul>
        
        <li><a class="post-link" href="/blog/2022/clac-embeddable.html" title="USACO 2017 Jan Gold Analysis">Embeddable Clac Execution Environment</a></li><li><a class="post-link" href="/blog/2022/Attention-Mechanism.html" title="USACO 2017 Jan Gold Analysis">NLP 101: Attention Mechanism</a></li><li><a class="post-link" href="/blog/2022/type-LaTeX-fast.html" title="USACO 2017 Jan Gold Analysis">How to Type LaTeX Fast &amp; Elegant - A Guide from &amp;...</a></li><li><a class="post-link" href="/blog/2022/Multi-heuristic-Astar.html" title="USACO 2017 Jan Gold Analysis">A* Search and its Variants</a></li></ul> -->
      
      
      
      <ul>
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/2D-Prefix-Sum.html" title="USACO 2017 Jan Gold Analysis">二维前缀和 2D Prefix Sum</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/Segment-Tree.html" title="USACO 2017 Jan Gold Analysis">线段树 Segment Tree</a></li>
            
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2020/USACO-2017-Dec-Gold.html" title="USACO 2017 Jan Gold Analysis">USACO 2017 Dec Gold Analysis</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2020/USACO-2017-Feb-Gold.html" title="USACO 2017 Jan Gold Analysis">USACO 2017 Feb Gold Analysis</a></li>
            
          
          
      </ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">目录</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      if (! h.getAttribute('hide-toc')){
        menuHTML += (
          '<li class="h-' + h.tagName.toLowerCase() + '">'
          + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
        }
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2019-2022 @Yutian (Mark) Chen</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/blog/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
