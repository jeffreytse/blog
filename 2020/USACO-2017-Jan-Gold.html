<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--<meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c"></meta>--><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>USACO 2017 Jan Gold Analysis | Yutian’s Blog</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="USACO 2017 Jan Gold Analysis">
<meta name="author" content="Yutian (Mark) Chen">
<meta property="og:locale" content="en_US">
<meta name="description" content="Problem 1 Balanced Photo Link to Problem Problem Summary John want to arrange his $N$ , $1\leq N \leq 100,000$ cows to take a photo. The height of $i$th cow is $h_i$. the heights of all cows are distinct. In a line, a cow is called “unbalanced” if the number of cow that is higher than it on the left is two time (or half of) the number of cow that is lower than it. Given the line of cow, give out the number of unbalanced cows in the photo. Proposed Solution First, we can range all the cows from high to low, and fill the array with the cow’s height. cows = [34, 6, 23, 0, 5, 99, 2] arr = [_ for _ in range(len(cows))] arr.sort(key=lambda x: cows[x]) After doing this, we can initialize a new list that used to store whether a cow has been counted. The new list will be filled with 0. l = [0] * len(cows) After this, we will apply following steps, suppose we are dealing with the $k$th highest cow, where cows[k] = n To decrease the time complexity of solution, we will use a data structure called Binary Index Tree (BIT) on $l$. Using BIT, we can calculate $L$, $R$, and update $l$ with time complexity of $O(\log{n})$. Calculate $L = \sum_{i = 0}^n l[i]$. Since we will process all the cows from highest to the shortest, the result of formula will be the number of cow that is higher than current cow and stands on its left. Calculate $R = k - 1 - \sum_{i = 0}^n l[i]$. Since the current cow we are dealing with is the $k$th highest cow, there are $k-1$ cows that are higher than current one. The cow that is higher than current cow and NOT on its left must stand on its right. Calculate \(\frac{\min{(L, R)}}{\max{(L, R)}}\) If the result is greater than 2, add the number of unbalanced cow by 1. Set the value of $l[n] = 1$. Time Complexity Analysis Time complexity of sorting - $O(n\log{n})$ Travel through all the cows - $O(n)$ Calculate L, R, and update $l[n]$ - $O(\log{n})$ Therefore, the total time complexity will be $O(n\log{n})$. Problem 2. Hoof, Paper, Scissors Problem Summary Hoof Paper Scissors is a game like paper, scissor, stone. In the game, Hoof &gt; Scissors, Scissors &gt; Paper, and Paper &gt; Hoof. The cow Bessie know the sequence of gesture that will be used by Farmer John, but it only can change its gesture for $k$ times, where $k$ is a number that is less than 20. Given the gesture sequence of farmer John and maximum number of change ($k$) for Bessie, what is the maximum number of games Bessie can win? Proposed Solution We can use the dynamic programming to solve this problem. First, we noticed that three variables are needed to represent a state for Bessie. The current gesture Bessie is using The number of game Bessie has won The number of time that Bessie change its gesture Therefore, we will build up a 3D array $T$ with size $3\times N \times k$, where $N$ is the number of games Bessie and John will have. $T[0][n][k]$ represent the maximum number of game that Bessie can win when it has “Hoof” at $n$th game and has changed its gesture for $k$ times. Suppose we have a function isWin(gesture, n) that will return whether Bessie will win. If Bessie wins, return 1; otherwise, return 0. Then we can calculate through the whole table using these equations: \(\begin{aligned} T[g][n][k] = \max{\left( T[g][n-1][k]+ isWin(g, n),\;\\ T[(g+1)\%3][n-1][k-1]+ isWin(g, n),\;\\ T[(g + 2)\%3][n-1][k-1]+ isWin(g, n) \right)} \end{aligned}\) If either $n$ or $k$ is out of bound (not in 3D array $T$, return 0. After calculating through all the table, we should check all the elements in slice $T[][N][]$. (the maximum win number may not require maximum number of change). The final result will be the maximum value of these $3\times k$ values. Time Complexity Analysis Since we know that $1\leq N\leq 100,000$ and $1\leq k\leq 20$, the 3D array we will construct has a size of $3\times100,000\times20 = 6\times 10^7$. Since we need to calculate through the whole table, our program may require $1\times 10^8$ computational steps and time complexity of $O(kN)$. Since this time complexity is on the edge of TLE, we should use Java to solve this problem. Problem 3. Cow Navigation Link to Problem Problem Summary Bessie is in the barn of John. The barn has a size of $N\times N$, and some of the square cells are impassable. Bessie starts in the lower-left corner (cell 1, 1) and wants to move to the right corner (cell N, N). In each second, Bessie can either go forward, turn left, or turn right. If one instruction let it enter an impassable square, it will skip through that instruction. At the beginning, Bessie doesn’t know if she starts out facing up or facing left. You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal, she will ignore further commands. Proposed Solution The difficult point in this problem is that we don’t know whether Bessie starts with which position and we have to make sure it can arrive at the destination. Since in each situation, the series of instructions used are the same, we can apply BFS on each situation simultaneously. In this BFS, each state will have two “sub-state”, which represent the position and direction of Bessie when start pointing upward and pointing rightward. We can also apply dynamic programming on this problem - if a set of instruction can reach the same state with shorter length, we should use the shorter instruction series. We will construct a table with size $N\times N \times 4 \times N \times N \times 4$. The first part $N\times N \times 4$ is the DP table for first sub-state. The second part of table is the DP-table for second sub-state. The update of DP table and state transition of BFS will follow these rules: \[T[S_1, S_2] = \min{(T[S_1, S_2], T[S_1', S_2'] + 1)}\] \[Update(S_1, S_2) = S_1, S_2' \text{ if $S_1$ is at final state}\] \[Update(S_1, S_2) = S_1',S_2 \text{ if the update will let $S_2$ get into impassable square}\] Time Complexity Analysis Therefore, we will search through a graph with $O(N^4)$ nodes. (For each sub-state, there are $N^2$ nodes, though for most of the time, the sub-states has same position, the overall upper bound is $O(N^4)$). Since $0\leq N\leq 20$, the proposed solution will be fast enough.">
<meta property="og:description" content="Problem 1 Balanced Photo Link to Problem Problem Summary John want to arrange his $N$ , $1\leq N \leq 100,000$ cows to take a photo. The height of $i$th cow is $h_i$. the heights of all cows are distinct. In a line, a cow is called “unbalanced” if the number of cow that is higher than it on the left is two time (or half of) the number of cow that is lower than it. Given the line of cow, give out the number of unbalanced cows in the photo. Proposed Solution First, we can range all the cows from high to low, and fill the array with the cow’s height. cows = [34, 6, 23, 0, 5, 99, 2] arr = [_ for _ in range(len(cows))] arr.sort(key=lambda x: cows[x]) After doing this, we can initialize a new list that used to store whether a cow has been counted. The new list will be filled with 0. l = [0] * len(cows) After this, we will apply following steps, suppose we are dealing with the $k$th highest cow, where cows[k] = n To decrease the time complexity of solution, we will use a data structure called Binary Index Tree (BIT) on $l$. Using BIT, we can calculate $L$, $R$, and update $l$ with time complexity of $O(\log{n})$. Calculate $L = \sum_{i = 0}^n l[i]$. Since we will process all the cows from highest to the shortest, the result of formula will be the number of cow that is higher than current cow and stands on its left. Calculate $R = k - 1 - \sum_{i = 0}^n l[i]$. Since the current cow we are dealing with is the $k$th highest cow, there are $k-1$ cows that are higher than current one. The cow that is higher than current cow and NOT on its left must stand on its right. Calculate \(\frac{\min{(L, R)}}{\max{(L, R)}}\) If the result is greater than 2, add the number of unbalanced cow by 1. Set the value of $l[n] = 1$. Time Complexity Analysis Time complexity of sorting - $O(n\log{n})$ Travel through all the cows - $O(n)$ Calculate L, R, and update $l[n]$ - $O(\log{n})$ Therefore, the total time complexity will be $O(n\log{n})$. Problem 2. Hoof, Paper, Scissors Problem Summary Hoof Paper Scissors is a game like paper, scissor, stone. In the game, Hoof &gt; Scissors, Scissors &gt; Paper, and Paper &gt; Hoof. The cow Bessie know the sequence of gesture that will be used by Farmer John, but it only can change its gesture for $k$ times, where $k$ is a number that is less than 20. Given the gesture sequence of farmer John and maximum number of change ($k$) for Bessie, what is the maximum number of games Bessie can win? Proposed Solution We can use the dynamic programming to solve this problem. First, we noticed that three variables are needed to represent a state for Bessie. The current gesture Bessie is using The number of game Bessie has won The number of time that Bessie change its gesture Therefore, we will build up a 3D array $T$ with size $3\times N \times k$, where $N$ is the number of games Bessie and John will have. $T[0][n][k]$ represent the maximum number of game that Bessie can win when it has “Hoof” at $n$th game and has changed its gesture for $k$ times. Suppose we have a function isWin(gesture, n) that will return whether Bessie will win. If Bessie wins, return 1; otherwise, return 0. Then we can calculate through the whole table using these equations: \(\begin{aligned} T[g][n][k] = \max{\left( T[g][n-1][k]+ isWin(g, n),\;\\ T[(g+1)\%3][n-1][k-1]+ isWin(g, n),\;\\ T[(g + 2)\%3][n-1][k-1]+ isWin(g, n) \right)} \end{aligned}\) If either $n$ or $k$ is out of bound (not in 3D array $T$, return 0. After calculating through all the table, we should check all the elements in slice $T[][N][]$. (the maximum win number may not require maximum number of change). The final result will be the maximum value of these $3\times k$ values. Time Complexity Analysis Since we know that $1\leq N\leq 100,000$ and $1\leq k\leq 20$, the 3D array we will construct has a size of $3\times100,000\times20 = 6\times 10^7$. Since we need to calculate through the whole table, our program may require $1\times 10^8$ computational steps and time complexity of $O(kN)$. Since this time complexity is on the edge of TLE, we should use Java to solve this problem. Problem 3. Cow Navigation Link to Problem Problem Summary Bessie is in the barn of John. The barn has a size of $N\times N$, and some of the square cells are impassable. Bessie starts in the lower-left corner (cell 1, 1) and wants to move to the right corner (cell N, N). In each second, Bessie can either go forward, turn left, or turn right. If one instruction let it enter an impassable square, it will skip through that instruction. At the beginning, Bessie doesn’t know if she starts out facing up or facing left. You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal, she will ignore further commands. Proposed Solution The difficult point in this problem is that we don’t know whether Bessie starts with which position and we have to make sure it can arrive at the destination. Since in each situation, the series of instructions used are the same, we can apply BFS on each situation simultaneously. In this BFS, each state will have two “sub-state”, which represent the position and direction of Bessie when start pointing upward and pointing rightward. We can also apply dynamic programming on this problem - if a set of instruction can reach the same state with shorter length, we should use the shorter instruction series. We will construct a table with size $N\times N \times 4 \times N \times N \times 4$. The first part $N\times N \times 4$ is the DP table for first sub-state. The second part of table is the DP-table for second sub-state. The update of DP table and state transition of BFS will follow these rules: \[T[S_1, S_2] = \min{(T[S_1, S_2], T[S_1', S_2'] + 1)}\] \[Update(S_1, S_2) = S_1, S_2' \text{ if $S_1$ is at final state}\] \[Update(S_1, S_2) = S_1',S_2 \text{ if the update will let $S_2$ get into impassable square}\] Time Complexity Analysis Therefore, we will search through a graph with $O(N^4)$ nodes. (For each sub-state, there are $N^2$ nodes, though for most of the time, the sub-states has same position, the overall upper bound is $O(N^4)$). Since $0\leq N\leq 20$, the proposed solution will be fast enough.">
<link rel="canonical" href="https://markchenyutian.github.io//blog/2020/USACO-2017-Jan-Gold.html">
<meta property="og:url" content="https://markchenyutian.github.io//blog/2020/USACO-2017-Jan-Gold.html">
<meta property="og:site_name" content="Yutian’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-11-11T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="USACO 2017 Jan Gold Analysis">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yutian (Mark) Chen"},"dateModified":"2020-11-11T00:00:00+00:00","datePublished":"2020-11-11T00:00:00+00:00","description":"Problem 1 Balanced Photo Link to Problem Problem Summary John want to arrange his $N$ , $1\\leq N \\leq 100,000$ cows to take a photo. The height of $i$th cow is $h_i$. the heights of all cows are distinct. In a line, a cow is called “unbalanced” if the number of cow that is higher than it on the left is two time (or half of) the number of cow that is lower than it. Given the line of cow, give out the number of unbalanced cows in the photo. Proposed Solution First, we can range all the cows from high to low, and fill the array with the cow’s height. cows = [34, 6, 23, 0, 5, 99, 2] arr = [_ for _ in range(len(cows))] arr.sort(key=lambda x: cows[x]) After doing this, we can initialize a new list that used to store whether a cow has been counted. The new list will be filled with 0. l = [0] * len(cows) After this, we will apply following steps, suppose we are dealing with the $k$th highest cow, where cows[k] = n To decrease the time complexity of solution, we will use a data structure called Binary Index Tree (BIT) on $l$. Using BIT, we can calculate $L$, $R$, and update $l$ with time complexity of $O(\\log{n})$. Calculate $L = \\sum_{i = 0}^n l[i]$. Since we will process all the cows from highest to the shortest, the result of formula will be the number of cow that is higher than current cow and stands on its left. Calculate $R = k - 1 - \\sum_{i = 0}^n l[i]$. Since the current cow we are dealing with is the $k$th highest cow, there are $k-1$ cows that are higher than current one. The cow that is higher than current cow and NOT on its left must stand on its right. Calculate \\(\\frac{\\min{(L, R)}}{\\max{(L, R)}}\\) If the result is greater than 2, add the number of unbalanced cow by 1. Set the value of $l[n] = 1$. Time Complexity Analysis Time complexity of sorting - $O(n\\log{n})$ Travel through all the cows - $O(n)$ Calculate L, R, and update $l[n]$ - $O(\\log{n})$ Therefore, the total time complexity will be $O(n\\log{n})$. Problem 2. Hoof, Paper, Scissors Problem Summary Hoof Paper Scissors is a game like paper, scissor, stone. In the game, Hoof &gt; Scissors, Scissors &gt; Paper, and Paper &gt; Hoof. The cow Bessie know the sequence of gesture that will be used by Farmer John, but it only can change its gesture for $k$ times, where $k$ is a number that is less than 20. Given the gesture sequence of farmer John and maximum number of change ($k$) for Bessie, what is the maximum number of games Bessie can win? Proposed Solution We can use the dynamic programming to solve this problem. First, we noticed that three variables are needed to represent a state for Bessie. The current gesture Bessie is using The number of game Bessie has won The number of time that Bessie change its gesture Therefore, we will build up a 3D array $T$ with size $3\\times N \\times k$, where $N$ is the number of games Bessie and John will have. $T[0][n][k]$ represent the maximum number of game that Bessie can win when it has “Hoof” at $n$th game and has changed its gesture for $k$ times. Suppose we have a function isWin(gesture, n) that will return whether Bessie will win. If Bessie wins, return 1; otherwise, return 0. Then we can calculate through the whole table using these equations: \\(\\begin{aligned} T[g][n][k] = \\max{\\left( T[g][n-1][k]+ isWin(g, n),\\;\\\\ T[(g+1)\\%3][n-1][k-1]+ isWin(g, n),\\;\\\\ T[(g + 2)\\%3][n-1][k-1]+ isWin(g, n) \\right)} \\end{aligned}\\) If either $n$ or $k$ is out of bound (not in 3D array $T$, return 0. After calculating through all the table, we should check all the elements in slice $T[][N][]$. (the maximum win number may not require maximum number of change). The final result will be the maximum value of these $3\\times k$ values. Time Complexity Analysis Since we know that $1\\leq N\\leq 100,000$ and $1\\leq k\\leq 20$, the 3D array we will construct has a size of $3\\times100,000\\times20 = 6\\times 10^7$. Since we need to calculate through the whole table, our program may require $1\\times 10^8$ computational steps and time complexity of $O(kN)$. Since this time complexity is on the edge of TLE, we should use Java to solve this problem. Problem 3. Cow Navigation Link to Problem Problem Summary Bessie is in the barn of John. The barn has a size of $N\\times N$, and some of the square cells are impassable. Bessie starts in the lower-left corner (cell 1, 1) and wants to move to the right corner (cell N, N). In each second, Bessie can either go forward, turn left, or turn right. If one instruction let it enter an impassable square, it will skip through that instruction. At the beginning, Bessie doesn’t know if she starts out facing up or facing left. You need to give the shortest sequence of directions that will guide her to the goal regardless of which case is true. Once she reaches the goal, she will ignore further commands. Proposed Solution The difficult point in this problem is that we don’t know whether Bessie starts with which position and we have to make sure it can arrive at the destination. Since in each situation, the series of instructions used are the same, we can apply BFS on each situation simultaneously. In this BFS, each state will have two “sub-state”, which represent the position and direction of Bessie when start pointing upward and pointing rightward. We can also apply dynamic programming on this problem - if a set of instruction can reach the same state with shorter length, we should use the shorter instruction series. We will construct a table with size $N\\times N \\times 4 \\times N \\times N \\times 4$. The first part $N\\times N \\times 4$ is the DP table for first sub-state. The second part of table is the DP-table for second sub-state. The update of DP table and state transition of BFS will follow these rules: \\[T[S_1, S_2] = \\min{(T[S_1, S_2], T[S_1&#39;, S_2&#39;] + 1)}\\] \\[Update(S_1, S_2) = S_1, S_2&#39; \\text{ if $S_1$ is at final state}\\] \\[Update(S_1, S_2) = S_1&#39;,S_2 \\text{ if the update will let $S_2$ get into impassable square}\\] Time Complexity Analysis Therefore, we will search through a graph with $O(N^4)$ nodes. (For each sub-state, there are $N^2$ nodes, though for most of the time, the sub-states has same position, the overall upper bound is $O(N^4)$). Since $0\\leq N\\leq 20$, the proposed solution will be fast enough.","headline":"USACO 2017 Jan Gold Analysis","mainEntityOfPage":{"@type":"WebPage","@id":"https://markchenyutian.github.io//blog/2020/USACO-2017-Jan-Gold.html"},"url":"https://markchenyutian.github.io//blog/2020/USACO-2017-Jan-Gold.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/blog/assets/css/main.css">
  <script src="/blog/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://markchenyutian.github.io//blog/feed.xml" title="Yutian's Blog">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      skipTags:['script', 'noscript', 'style', 'textarea', 'pre'],
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>



















<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<!-- | default: default_paths - --><span class="site-brand"><a class="site-brand-inner" rel="author" href="/blog/">
  <img class="site-favicon" title="Yutian's Blog" src="" onerror="this.style.display='none'">
  Yutian's Blog
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/blog/about.html">ABOUT</a><a class="page-link" href="/blog/posts.html">POSTS</a><a class="page-link" href="/blog/files.html">FILES</a>




<span class="page-link">

<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="Franch">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: '',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>










































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">USACO 2017 Jan Gold Analysis</h1>
  <h3 class="post-subtitle"></h3>

  <p class="post-meta">
    <time class="dt-published" datetime="2020-11-11T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Nov 11, 2020
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 20 mins</span>

    <!-- Read Count Insert Here -->
  </p>
<div class="post-tags"><a class="post-tag" href="/blog/tags.html#Algorithm">#Algorithm</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="problem-1-balanced-photo">Problem 1 Balanced Photo</h2>

<p><a href="http://usaco.org/index.php?page=viewproblem2&cpid=693">Link to Problem</a></p>

<h3 id="problem-summary">Problem Summary</h3>

<p>John want to arrange his $N$ , $1\leq N \leq 100,000$ cows to take a photo. The height of $i$th cow is $h_i$. the heights of all cows are distinct. In a line, a cow is called “unbalanced” if the number of cow that is higher than it on the left is two time (or half of) the number of cow that is lower than it. Given the line of cow, give out the number of unbalanced cows in the photo.</p>

<h3 id="proposed-solution">Proposed Solution</h3>

<p>First, we can range all the cows from high to low, and fill the array with the cow’s height.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cows</span> <span class="o">=</span> <span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">99</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cows</span><span class="p">))]</span>
<span class="n">arr</span><span class="p">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cows</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
</code></pre></div></div>

<p>After doing this, we can initialize a new list that used to store whether a cow has been counted. The new list will be filled with 0.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">cows</span><span class="p">)</span>
</code></pre></div></div>

<p>After this, we will apply following steps, suppose we are dealing with the $k$th highest cow, where <code class="language-plaintext highlighter-rouge">cows[k] = n</code></p>

<p>To decrease the time complexity of solution, we will use a data structure called <strong>Binary Index Tree (BIT)</strong> on $l$. Using BIT, we can calculate $L$, $R$, and update $l$ with time complexity of $O(\log{n})$.</p>

<ol>
  <li>
    <p>Calculate  $L = \sum_{i = 0}^n l[i]$. Since we will process all the cows from highest to the shortest, the result of formula will be the number of cow that is higher than current cow and stands on its left.</p>
  </li>
  <li>
    <p>Calculate $R = k - 1 - \sum_{i = 0}^n l[i]$. Since the current cow we are dealing with is the $k$th highest cow, there are $k-1$ cows that are higher than current one. The cow that is higher than current cow and NOT on its left must stand on its right.</p>
  </li>
  <li>
    <p>Calculate
$$
\frac{\min{(L, R)}}{\max{(L, R)}}
$$
If the result is greater than 2, add the number of unbalanced cow by 1.</p>
  </li>
  <li>
    <p>Set the value of $l[n] = 1$.</p>
  </li>
</ol>

<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>

<ul>
  <li>Time complexity of sorting - $O(n\log{n})$</li>
  <li>Travel through all the cows - $O(n)$
    <ul>
      <li>Calculate L, R, and update $l[n]$ - $O(\log{n})$</li>
    </ul>
  </li>
</ul>

<p>Therefore, the total time complexity will be $O(n\log{n})$.</p>

<h2 id="problem-2-hoof-paper-scissors">Problem 2. Hoof, Paper, Scissors</h2>

<h3 id="problem-summary-1">Problem Summary</h3>

<p>Hoof Paper Scissors is a game like paper, scissor, stone. In the game, Hoof &gt; Scissors, Scissors &gt; Paper, and Paper &gt; Hoof. The cow Bessie know the sequence of gesture that will be used by Farmer John, but it only can change its gesture for $k$ times, where $k$ is a number that is less than 20.</p>

<p>Given the gesture sequence of farmer John and maximum number of change ($k$) for Bessie, what is the maximum number of games Bessie can win?</p>

<h3 id="proposed-solution-1">Proposed Solution</h3>

<p>We can use the dynamic programming to solve this problem. First, we noticed that three variables are needed to represent a state for Bessie.</p>

<ol>
  <li>The current gesture Bessie is using</li>
  <li>The number of game Bessie has won</li>
  <li>The number of time that Bessie change its gesture</li>
</ol>

<p>Therefore, we will build up a 3D array $T$ with size $3\times N \times k$, where $N$ is the number of games Bessie and John will have. $T[0][n][k]$ represent the maximum number of game that Bessie can win when it has “Hoof” at $n$th game and has changed its gesture for $k$ times.</p>

<p>Suppose we have a function <code class="language-plaintext highlighter-rouge">isWin(gesture, n)</code> that will return whether Bessie will win. If Bessie wins, return 1; otherwise, return 0. Then we can calculate through the whole table using these equations:
$$
\begin{aligned}
T[g][n][k] = \max{\left( T[g][n-1][k]+ isWin(g, n),\;\<br>
T[(g+1)\%3][n-1][k-1]+ isWin(g, n),\;\<br>
T[(g + 2)\%3][n-1][k-1]+ isWin(g, n) \right)} 
\end{aligned}
$$
If either $n$ or $k$ is out of bound (not in 3D array $T$, return 0.</p>

<p>After calculating through all the table, we should check all the elements in slice $T[][N][]$. (the maximum win number may not require maximum number of change). The final result will be the maximum value of these $3\times k$ values.</p>

<h3 id="time-complexity-analysis-1">Time Complexity Analysis</h3>

<p>Since we know that $1\leq N\leq 100,000$ and $1\leq k\leq 20$, the 3D array we will construct has a size of $3\times100,000\times20 = 6\times 10^7$. Since we need to calculate through the whole table, our program may require $1\times 10^8$ computational steps and time complexity of $O(kN)$. Since this time complexity is on the edge of TLE, we should use Java to solve this problem.</p>

<h2 id="problem-3-cow-navigation">Problem 3. Cow Navigation</h2>

<p><a href="http://usaco.org/index.php?page=viewproblem2&cpid=695">Link to Problem</a></p>

<h3 id="problem-summary-2">Problem Summary</h3>

<p>Bessie is in the barn of John. The barn has a size of $N\times N$, and some of the square cells are impassable. Bessie starts in the lower-left corner (cell 1, 1) and wants to move to the right corner (cell N, N).</p>

<p>In each second, Bessie can either <strong>go forward</strong>, <strong>turn left</strong>, or <strong>turn right</strong>. If one instruction let it enter an impassable square, it will skip through that instruction. At the beginning, Bessie doesn’t know if she starts out facing up or facing left. You need to give the <strong>shortest sequence of directions</strong> that will guide her to the goal <strong>regardless of which case is true.</strong> Once she reaches the goal, she will ignore further commands.</p>

<h3 id="proposed-solution-2">Proposed Solution</h3>

<p>The difficult point in this problem is that we don’t know whether Bessie starts with which position and we have to make sure it can arrive at the destination. Since in each situation, the series of instructions used are the same, we can apply BFS on each situation simultaneously.</p>

<p>In this BFS, each state will have two “sub-state”, which represent the position and direction of Bessie when start pointing upward and pointing rightward. We can also apply dynamic programming on this problem - if a set of instruction can reach the same state with shorter length, we should use the shorter instruction series.</p>

<p>We will construct a table with size $N\times N \times 4 \times N \times N \times 4$. The first part $N\times N \times 4$ is the DP table for first sub-state. The second part of table is the DP-table for second sub-state.</p>

<p>The update of DP table and state transition of BFS will follow these rules:</p>

<ol>
  <li>
    <p>$$
T[S_1, S_2] = \min{(T[S_1, S_2], T[S_1’, S_2’] + 1)}
$$</p>
  </li>
  <li>
    <p>$$
Update(S_1, S_2) = S_1, S_2’ \text{  if $S_1$ is at final state}
$$</p>
  </li>
  <li>
    <p>$$
Update(S_1, S_2) = S_1’,S_2 \text{ if the update will let $S_2$ get into impassable square}
$$</p>
  </li>
</ol>

<h3 id="time-complexity-analysis-2">Time Complexity Analysis</h3>

<p>Therefore, we will search through a graph with $O(N^4)$ nodes. (For each sub-state, there are $N^2$ nodes, though for most of the time, the sub-states has same position, the overall upper bound is $O(N^4)$). Since $0\leq N\leq 20$, the proposed solution will be fast enough.</p>


    </div>

</article>
<div class="post-nav">
<a class="previous" href="/blog/2020/USACO-2016-Dec-Gold.html" title="USACO 2016 Dec Gold Analysis">USACO 2016 Dec Gold Analysis</a><a class="next" href="/blog/2020/Binary-Index-Tree.html" title="Binary Index Tree (Fenwick Tree)">Binary Index Tree (Fenwick Tree)</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <!-- <ul>
        
        <li><a class="post-link" href="/blog/2022/Transformers.html" title="Binary Index Tree (Fenwick Tree)">NLP 101: Transformer Model</a></li><li><a class="post-link" href="/blog/2021/Word-Embedding.html" title="Binary Index Tree (Fenwick Tree)">NLP 101: Word Embedding 词嵌入</a></li><li><a class="post-link" href="/blog/2022/the-fences.html" title="Binary Index Tree (Fenwick Tree)">The Fences | AR Web Application</a></li><li><a class="post-link" href="/blog/2022/type-LaTeX-fast.html" title="Binary Index Tree (Fenwick Tree)">How to Type LaTeX Fast &amp; Elegant - A Guide from &amp;...</a></li></ul> -->
      
      
      
      <ul>
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/2D-Prefix-Sum.html" title="Binary Index Tree (Fenwick Tree)">二维前缀和 2D Prefix Sum</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/Segment-Tree.html" title="Binary Index Tree (Fenwick Tree)">线段树 Segment Tree</a></li>
            
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2020/USACO-2017-Dec-Gold.html" title="Binary Index Tree (Fenwick Tree)">USACO 2017 Dec Gold Analysis</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2020/USACO-2017-Feb-Gold.html" title="Binary Index Tree (Fenwick Tree)">USACO 2017 Feb Gold Analysis</a></li>
            
          
          
      </ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">目录</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      if (! h.getAttribute('hide-toc')){
        menuHTML += (
          '<li class="h-' + h.tagName.toLowerCase() + '">'
          + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
        }
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2019-2022 @Yutian (Mark) Chen</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/blog/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
