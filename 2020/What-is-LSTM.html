<!DOCTYPE html>
<html lang="ch">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!--<meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c"></meta>--><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>长短期记忆递归网络 LSTM | Yutian’s Blog</title>
<meta name="generator" content="Jekyll v4.2.2">
<meta property="og:title" content="长短期记忆递归网络 LSTM">
<meta name="author" content="Yutian (Mark) Chen">
<meta property="og:locale" content="ch">
<meta name="description" content="一般的神经网络只能处理单个信息，可是有的时候神经网络的输入是一个时间序列，在这种情况下普通的前馈神经网络就不能利用“上下文”中隐含的信息来更好的处理当前输入。为了解决这个问题，人们提出了递归神经网络(Recurrent Neural Network, RNN)。可是递归神经网络也有问题：由于同样的权重在网络中一直被累乘，在反向传播的时候极容易出现梯度消失与梯度爆炸的问题。同时，由于RNN在状态间传递的信息过少，RNN在上下文距离较远的时候会很快的遗忘前文信息。为了解决这些问题，人们提出了LSTM这个新的网络模型，它可以很好的处理以上这些问题。">
<meta property="og:description" content="一般的神经网络只能处理单个信息，可是有的时候神经网络的输入是一个时间序列，在这种情况下普通的前馈神经网络就不能利用“上下文”中隐含的信息来更好的处理当前输入。为了解决这个问题，人们提出了递归神经网络(Recurrent Neural Network, RNN)。可是递归神经网络也有问题：由于同样的权重在网络中一直被累乘，在反向传播的时候极容易出现梯度消失与梯度爆炸的问题。同时，由于RNN在状态间传递的信息过少，RNN在上下文距离较远的时候会很快的遗忘前文信息。为了解决这些问题，人们提出了LSTM这个新的网络模型，它可以很好的处理以上这些问题。">
<link rel="canonical" href="https://markchenyutian.github.io//blog/2020/What-is-LSTM.html">
<meta property="og:url" content="https://markchenyutian.github.io//blog/2020/What-is-LSTM.html">
<meta property="og:site_name" content="Yutian’s Blog">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2020-04-03T00:00:00+00:00">
<meta name="twitter:card" content="summary">
<meta property="twitter:title" content="长短期记忆递归网络 LSTM">
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Yutian (Mark) Chen"},"dateModified":"2020-04-03T00:00:00+00:00","datePublished":"2020-04-03T00:00:00+00:00","description":"一般的神经网络只能处理单个信息，可是有的时候神经网络的输入是一个时间序列，在这种情况下普通的前馈神经网络就不能利用“上下文”中隐含的信息来更好的处理当前输入。为了解决这个问题，人们提出了递归神经网络(Recurrent Neural Network, RNN)。可是递归神经网络也有问题：由于同样的权重在网络中一直被累乘，在反向传播的时候极容易出现梯度消失与梯度爆炸的问题。同时，由于RNN在状态间传递的信息过少，RNN在上下文距离较远的时候会很快的遗忘前文信息。为了解决这些问题，人们提出了LSTM这个新的网络模型，它可以很好的处理以上这些问题。","headline":"长短期记忆递归网络 LSTM","mainEntityOfPage":{"@type":"WebPage","@id":"https://markchenyutian.github.io//blog/2020/What-is-LSTM.html"},"url":"https://markchenyutian.github.io//blog/2020/What-is-LSTM.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="shortcut icon" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/blog/assets/css/main.css">
  <script src="/blog/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="https://markchenyutian.github.io//blog/feed.xml" title="Yutian's Blog">
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      skipTags:['script', 'noscript', 'style', 'textarea', 'pre'],
    },
    svg: {
      fontCache: 'global'
    }
  };
</script>
<script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
</script>
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>



















<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner">
<!-- | default: default_paths - --><span class="site-brand"><a class="site-brand-inner" rel="author" href="/blog/">
  <img class="site-favicon" title="Yutian's Blog" src="" onerror="this.style.display='none'">
  Yutian's Blog
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger">
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewbox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
              </svg>
            </span>
          </label>

          <div class="trigger">
<a class="page-link" href="/blog/about.html">ABOUT</a><a class="page-link" href="/blog/posts.html">POSTS</a><a class="page-link" href="/blog/files.html">FILES</a>




<span class="page-link">

<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="Franch">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: '',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="//translate.google.com/translate_a/element.js?cb=googleTranslateElementInit"></script>
</span>
</div>
        </nav>
</div>
  </div>
</header>

<script>
  (function() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  })();
</script>











































  <section class="page-banner">
    <div class="page-banner-img">
      <div style="background-image: url(/blog/assets/images/banners/NeuralNetworkBackground.jpg)"></div>
    </div>
    <div class="wrapper">
      <div class="page-banner-inner">
<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">长短期记忆递归网络 LSTM</h1>
  <h3 class="post-subtitle"></h3>

  <p class="post-meta">
    <time class="dt-published" datetime="2020-04-03T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Apr 03, 2020
    </time>

    
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 38 mins</span>

    <!-- Read Count Insert Here -->
  </p>
<div class="post-tags">
<a class="post-tag" href="/blog/tags.html#Neural%20Network">#Neural Network</a><a class="post-tag" href="/blog/tags.html#NLP">#NLP</a>
</div></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <p>一般的神经网络只能处理单个信息，可是有的时候神经网络的输入是一个时间序列，在这种情况下普通的前馈神经网络就不能利用“上下文”中隐含的信息来更好的处理当前输入。为了解决这个问题，人们提出了递归神经网络(Recurrent Neural Network, RNN)。可是递归神经网络也有问题：由于同样的权重在网络中一直被累乘，在反向传播的时候极容易出现梯度消失与梯度爆炸的问题。同时，由于RNN在状态间传递的信息过少，RNN在上下文距离较远的时候会很快的遗忘前文信息。为了解决这些问题，人们提出了LSTM这个新的网络模型，它可以很好的处理以上这些问题。</p>

<hr>

<h2 id="0-什么是lstm">0. 什么是LSTM</h2>

<p>LSTM，全称 Long Short Term Memory (长短期记忆) 是一种特殊的<strong>递归神经网络</strong> 。这种网络与一般的前馈神经网络不同，LSTM可以利用时间序列对输入进行分析；简而言之，当使用前馈神经网络时，神经网络会认为我们$t$时刻输入的内容与$t + 1$时刻输入的内容<strong>完全无关</strong>，对于许多情况，例如图片分类识别，这是毫无问题的，可是对于一些情景，例如<strong>自然语言处理</strong> (NLP, Natural Language Processing) 或者我们需要分析类似于<strong>连拍照片</strong>这样的数据时，合理运用 $t$ 或之前的输入来处理 $t+n$ 时刻显然可以更加合理的运用输入的信息。为了运用到时间维度上信息，人们设计了<strong>递归神经网络</strong> (RNN, Recurssion Neural Network)，一个简单的递归神经网络可以用这种方式表示</p>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200402223614052.png" alt="image-20200402223614052"></p>

<p>在图中，$x_t$是在$t$时刻的输入信息，$h_t$是在$t$时刻的输入信息，我们可以看到神经元$A$会递归的调用自身并且将$t -1$时刻的信息传递给$t$时刻。</p>

<p>递归神经网络在许多情况下运行良好，特别是在对<strong>短时间序列</strong>数据的分析时十分方便。但是，注意到前面着重强调了“短”，这是为什么呢？</p>

<p>上图所示的简单递归神经网络存在一个“硬伤“，<strong>长期依赖问题</strong>：递归神经网络只能处理我们需要较接近的上下文的情况：</p>

<blockquote>
  <p>Example 1. 想象现在设计了一个基于简单RNN的句子自动补全器，当我输入”Sea is …” 的时候会自动补全为”Sea is <strong>blue</strong>“。</p>
</blockquote>

<p>在这种情况下，我们需要的上下文极短，而RNN可以很好的收集到 $t = 0$时的信息”Sea”并且补上”blue”</p>

<blockquote>
  <p>Example 2. 现在，假设我们用刚刚的RNN试图补全一篇文章”我一直呆在中国，……，我会说一口流利的 (?)”。</p>
</blockquote>

<p>在这里，为了补全最后的空缺，需要的信息在非常远的上文（e.g. 200+字前）提到的”中国“。在实验中简单的理想状态下，经过精心调节的RNN超参数可以良好的将这些信息向后传递。可是在现实的情况中，基本没有RNN可以做到这一点。一些学者后来研究发现RNN的长期依赖问题是这种网络结构本身的问题。</p>

<p>不但如此，这种简单的RNN还很容易受到两种在神经网络中臭名昭著的影响<strong>梯度消失问题</strong>（神经网络的权重/偏置梯度极小，导致神经网络参数调整速率急剧下降）和<strong>梯度爆炸问题</strong>（神经网络的权重/偏置极大，导致神经网络参数调整幅度过大，矫枉过正）。相信大家都看过一个著名的鸡汤，$(0.99)^{365}$和$(1.01)^{365}$的对比。实际上，这个鸡汤非常好的描述了梯度问题的本质：对于<strong>任意信息递归使用足够多次同样的计算</strong>，都会导致极大或极小的结果，也就是说…</p>

<p>根据微分链式法则，在RNN中，神经元的权重的梯度可以被表示为一系列函数的微分的连乘。因为神经元的参数（权重与偏置）都是基于学习速率（一般为常数）和参数梯度相反数（使得神经网络输出最快逼近目标输出）得到的，一个过大或过小的梯度会导致我们要么需要极长的训练时间（本来从-2.24 调节到 -1.99 只用500个样本，由于梯度过小，每次只调小0.0001，最后用了几千个样本），要么会导致参数调节过度（例如本来应该从-10.02调节到-9.97，由于梯度过大，直接调成了+20.3）</p>

<h2 id="1-为什么需要lstm">1. 为什么需要LSTM</h2>

<p>LSTM从被设计之初就被明确的用于解决一般递归神经网络中普遍存在的<strong>长期依赖问题</strong>，使用LSTM可以有效的传递和表达长时间序列中的信息并且不会导致长时间前的有用信息被忽略（遗忘）。与此同时，LSTM还可以解决RNN中的梯度消失/爆炸问题</p>

<h2 id="2-lstm-的直觉解释">2. LSTM 的直觉解释</h2>

<p>LSTM的设计或多或少的借鉴了人类对于自然语言处理的直觉性经验。要想了解LSTM的工作机制，可以先阅读一下一个（虚构的）淘宝评论：</p>

<blockquote>
  <p>“这个笔记本非常棒，纸很厚，料很足，用笔写起来手感非常舒服，而且没有一股刺鼻的油墨味；更加好的是这个笔记本不但便宜还做工优良，我上次在别家买的笔记本裁纸都裁不好，还会割伤手……”</p>
</blockquote>

<p>如果让你看完这段话以后马上转述，相信大多数人都会提取出来这段话中几个重要的关键词“纸好”，“没味道”，“做工好”，然后再重新组织成句子进行转述。这说明了以下两点：</p>

<ol>
  <li>在一个时间序列中，不是所有信息都是同等有效的，大多数情况存在“关键词”或者“关键帧”</li>
  <li>我们会在从头到尾阅读的时候“自动”概括已阅部分的内容并且用之前的内容帮助理解后文</li>
</ol>

<p>基于以上这两点，LSTM的设计者提出了“长短期记忆”的概念——只有一部分的信息需要长期的记忆，而有的信息可以不记下来</p>

<h2 id="3-lstm的具体解释">3. LSTM的具体解释</h2>

<p>一个普通的，使用tanh函数的RNN可以这么表示：</p>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200402233238756.png" alt="image-20200402233238756"></p>

<p>在这里，我们可以看到A在$t-1$时刻的输出值$h_t$被复制到了$t$时刻，与$t$时刻的输入$x_t$整合后经过一个带权重和偏置的tanh函数后形成输出，并继续将数据复制到$t+1$时刻……</p>

<p>与上图朴素的RNN相比，单个LSTM单元拥有更加复杂的内部结构和输入输出：</p>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200402233826864.png" alt="image-20200402233826864"></p>

<p>在上图中，每一个红色圆形代表对向量做出的操作（pointwise operation， 对位操作），而黄色的矩形代表一个神经网络层，上面的字符代表神经网络所使用的激活函数</p>

<blockquote>
  <p>point-wise operation 点对点操作</p>

  <p>​	如果我要对向量&lt;1, 2, 3&gt; 和 &lt;1, 3, 5&gt;进行逐分量的想成操作，会获得结果 &lt;1, 6, 15&gt;</p>
</blockquote>

<blockquote>
  <p>layer 函数层</p>

  <p>​	一个函数层拥有两个属性：权重向量(Weight) 和 偏置向量(bias)，对于输入向量$A$的每一个分量 $i$ ， 函数	层会对其进行以下操作(假设激活函数为$F(x)$)：
$$
Output_i = F(W_i \cdot A_i + b_i)
$$
​	常见的激活函数（也就是套在最外面的$F(x)$）有ReLU(线性修正单元)，sigmoid（写作$\sigma$），和 $\tanh$</p>
</blockquote>

<p>###　LSTM的关键：单元状态</p>

<p>LSTM能够从RNN中脱颖而出的关键就在于上图中从单元中贯穿而过的线 ——神经元的隐藏态，我们可以将神经元的隐藏态简单的理解成递归神经网络对于输入数据的“记忆”，用$C_t$表示神经元在$t$时刻过后的“记忆”，这个向量涵盖了在$t+1$时刻前神经网络对于所有输入信息的“概括总结”</p>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200402235227710.png" alt="image-20200402235227710"></p>

<p>接下来我们会看一下LSTM四个函数层分别在做些什么</p>

<h3 id="lstm_1-遗忘门">LSTM_1 遗忘门</h3>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200403003547037.png" alt="image-20200403003547037"></p>

<p>对于上一时刻LSTM中的单元状态来说，一些“信息”可能会随着时间的流逝而“过时”。为了不让过多记忆影响神经网络对现在输入的处理，我们应该选择性遗忘一些在之前单元状态中的分量——这个工作就交给了“遗忘门”</p>

<p>每一次输入一个新的输入，LSTM会先根据新的输入和上一时刻的输出决定遗忘掉之前的哪些记忆——输入和上一步的输出会整合为一个单独的向量，然后通过sigmoid神经层，最后点对点的乘在单元状态上。因为sigmoid 函数会将任意输入压缩到$(0, 1)$的区间上，我们可以非常直觉的得出这个门的工作原理 —— 如果整合后的向量某个分量在通过sigmoid层后变为0，那么显然单元状态对应的分量也会变成0，换句话说，“遗忘”了这个分量上的信息；如果某个分量通过sigmoid层后为1，单元状态会“保持完整记忆”。不同的sigmoid输出会带来不同信息的记忆与遗忘。通过这种方式，LSTM可以<strong>长期记忆重要信息</strong>，并且记忆可以随着时间进行动态调整</p>

<p>下面的公式可以用来描述遗忘门的计算，其中$f_t$就是sigmoid神经层的输出向量：
$$
f_t = \sigma(W_f\cdot [h_{t-1}, x_t] + b_f)
$$</p>

<h3 id="lstm_2--3-记忆门">LSTM_2 &amp; 3 记忆门</h3>

<p>记忆门是用来控制是否将在$t$时刻（现在）的数据并入单元状态中的控制单位。首先，用tanh函数层将现在的向量中的有效信息提取出来，然后使用（图上tanh函数层左侧）的sigmoid函数来控制这些记忆要放“多少”进入单元状态。这两者结合起来就可以做到：</p>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200403001917424.png" alt="image-20200403001917424"></p>

<ol>
  <li>从当前输入中提取有效信息</li>
  <li>对提取的有效信息做出筛选，为每个分量做出评级(0 ~ 1)，评级越高的最后会有越多的记忆进入单元状态</li>
</ol>

<p>下面的公式可以分别表示这两个步骤在LSTM中的计算：</p>

<ol>
  <li>
    <p>$$
C’<em>t = \tanh(W_c\cdot [h</em>{t - 1},x_t] + b_c)
$$</p>
  </li>
  <li>
    <p>$$
i_t = \sigma(W_i\cdot [h_{t-1}, x_t] + b_i)
$$</p>
  </li>
</ol>

<h3 id="lstm_4-输出门">LSTM_4 输出门</h3>

<p>输出门，顾名思义，就是LSTM单元用于计算当前时刻的输出值的神经层。输出层会先将当前输入值与上一时刻输出值整合后的向量（也就是公式中的$[h_{t - 1},x_t]$）用sigmoid函数提取其中的信息，接着，会将当前的单元状态通过tanh函数压缩映射到区间$(-1, 1)$中*</p>

<blockquote>
  <p><strong>为什么我们要在LSTM的输出门上使用tanh函数？</strong></p>

  <p>以下引用自Stack Overflow上问题 What is the intuition of using tanh in LSTM 中的最佳答案：</p>

  <p>https://stackoverflow.com/questions/40761185/what-is-the-intuition-of-using-tanh-in-lstm</p>

  <p>在LSTM的输入和输出门中使用tanh函数有以下几个原因：</p>

  <ol>
    <li>
      <p>为了防止<strong>梯度消失问题</strong>，我们需要一个二次导数在大范围内不为0的函数，而tanh函数可以满足这一点</p>
    </li>
    <li>为了便于凸优化，我们需要一个<strong>单调函数</strong>
</li>
    <li>tanh函数一般收敛的更快</li>
    <li>tanh函数的求导占用系统的资源更少</li>
  </ol>
</blockquote>

<p>将经过tanh函数处理后的单元状态与sigmoid函数处理后的，整合后的向量点对点的乘起来就可以得到LSTM在$t$时刻的输出了！</p>

<hr>

<h2 id="4-lstm-的变体">4. LSTM 的变体</h2>

<p>自从LSTM在自然语言处理等方面大获成功后，许多种LSTM的变体被提出，其中只有几种值得特别关注：</p>

<p><img src="Https://markchenyutian.github.io/Markchen_Blog/Asset/image-20200403021009010.png" alt="image-20200403021009010"></p>

<p>这种LSTM让各个门都可以在获得了上一时刻的单元状态的前提下进行运算。在上面的图中，单元状态被额外赋予到了所有三个层中（输出门除外），然而在实际的应用中，大部分研究者只会选择性的打开三个通道中的一或两个</p>

<p>除此之外，还有很多其他LSTM变体以及<strong>通过其他方式构建RNN达到类似LSTM的效果的架构</strong>，然而这些架构的效率都大同小异，所以不过多说明了</p>

<h2 id="5-参考资料">5. 参考资料</h2>

<p>[1] “Understanding LSTM Networks.” <em>Understanding LSTM Networks – Colah’s Blog</em>, colah.github.io/posts/2015-08-Understanding-LSTMs/.</p>

<p>[2] “Long Short-Term Memory.” <em>Wikipedia</em>, Wikimedia Foundation, 1 Apr. 2020, en.wikipedia.org/wiki/Long_short-term_memory.</p>

<p>[3] “LSTM以及三重门，遗忘门，输入门，输出门.” <em>LSTM以及三重门，遗忘门，输入门，输出门_网络_Lison_Zhu’s Blog-CSDN博客</em>, blog.csdn.net/Lison_Zhu/article/details/97236501.</p>

<p>[4] “递归神经网络问题整理.” <em>递归神经网络问题整理_网络_leo鱼的博客-CSDN博客</em>, blog.csdn.net/webzjuyujun/article/details/71124695.</p>

<p>[5] “详解机器学习中的梯度消失、爆炸原因及其解决方法.” <em>详解机器学习中的梯度消失、爆炸原因及其解决方法_网络_Double_V的博客-CSDN博客</em>, blog.csdn.net/qq_25737169/article/details/78847691.</p>

<p>[6] Dnkdnk. “What Is the Intuition of Using Tanh in LSTM.” <em>Stack Overflow</em>, 1 Sept. 1966, stackoverflow.com/questions/40761185/what-is-the-intuition-of-using-tanh-in-lstm.</p>



    </div>

</article>
<div class="post-nav">
<a class="previous" href="/blog/2020/U-net.html" title="医学图像分割模型 U-net">医学图像分割模型 U-net</a><a class="next" href="/blog/2020/What-is-Bayes-Network.html" title="什么是贝叶斯网络 | What is Bayes Network">什么是贝叶斯网络 | What is Bayes Network...</a>
</div>
<div class="post-related">
      <div>Related Articles</div>
      <!-- <ul>
        
        <li><a class="post-link" href="/blog/2022/type-LaTeX-fast.html" title="什么是贝叶斯网络 | What is Bayes Network">How to Type LaTeX Fast &amp; Elegant - A Guide from &amp;...</a></li><li><a class="post-link" href="/blog/2021/Word-Embedding.html" title="什么是贝叶斯网络 | What is Bayes Network">NLP 101: Word Embedding 词嵌入</a></li><li><a class="post-link" href="/blog/2021/Batch-Normalization.html" title="什么是贝叶斯网络 | What is Bayes Network">Batch Normalization 浅入深出</a></li><li><a class="post-link" href="/blog/2022/Attention-Mechanism.html" title="什么是贝叶斯网络 | What is Bayes Network">NLP 101: Attention Mechanism</a></li></ul> -->
      
      
      
      <ul>
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2022/Transformers.html" title="什么是贝叶斯网络 | What is Bayes Network">NLP 101: Transformer Model</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2022/Attention-Mechanism.html" title="什么是贝叶斯网络 | What is Bayes Network">NLP 101: Attention Mechanism</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/Seq2Seq.html" title="什么是贝叶斯网络 | What is Bayes Network">NLP 101: Seq2Seq 模型</a></li>
            
          
          
        
          
          
          
            <li><a class="post-link" href="/blog/2021/Batch-Normalization.html" title="什么是贝叶斯网络 | What is Bayes Network">Batch Normalization 浅入深出</a></li>
            
          
          
      </ul>
    </div>
<div class="post-comments"></div></section>
</div>


  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">目录</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      if (! h.getAttribute('hide-toc')){
        menuHTML += (
          '<li class="h-' + h.tagName.toLowerCase() + '">'
          + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
        }
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/blog/"></data>

  <div class="wrapper">
    <div class="site-footer-inner">
      <div>Copyright © 2019-2022 @Yutian (Mark) Chen</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="http://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/blog/feed.xml">via RSS</a>
</div>
    </div>
  </div>
</footer>
</body>
</html>
